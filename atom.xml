<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Duan</title>
  
  <subtitle>游刃有余</subtitle>
  <link href="http://duanyushuai.github.io/atom.xml" rel="self"/>
  
  <link href="http://duanyushuai.github.io/"/>
  <updated>2023-04-21T10:22:45.951Z</updated>
  <id>http://duanyushuai.github.io/</id>
  
  <author>
    <name>小段</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>垃圾回收器</title>
    <link href="http://duanyushuai.github.io/2023/10/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>http://duanyushuai.github.io/2023/10/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</id>
    <published>2023-10-18T02:00:00.000Z</published>
    <updated>2023-04-21T10:22:45.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><p><strong><code>i++</code>和<code>++i</code>的区别</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">i++;</span><br><span class="line"><span class="comment">//++i；</span></span><br><span class="line">sout(i)</span><br><span class="line"><span class="comment">//字节码是一样的</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 10;</span><br><span class="line">i = i++;</span><br><span class="line">sout(i)</span><br><span class="line">//输出是10 </span><br></pre></td></tr></table></figure><p><strong>str区别</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">      <span class="comment">// str.intern();</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">       System.out.println(str == str1);<span class="comment">//false --&gt; true (加上intern() 在str声明之前)</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="强引用、软引用、弱引用、虚引用"><a href="#强引用、软引用、弱引用、虚引用" class="headerlink" title="强引用、软引用、弱引用、虚引用"></a>强引用、软引用、弱引用、虚引用</h4><p>软引用对应的类为 java.lang.ref.SoftReference, 一个软引用中的对象，不会很快被JVM回收，JVM会根据当前堆的使用情况来判断何时回收，当堆的使用率超过阈值时，才回去回收软引用中的对象。</p><p>弱引用中的对象具有很短的声明周期，因为在系统GC时，只要发现弱引用，不管堆空间是否足够，都会将对象进行回收。由于垃圾回收器是一个<strong>优先级很低的线程</strong>，因此<strong>不一定</strong>会<strong>很快</strong>发现那些只具有<strong>弱引用</strong>的对象。</p><p>虚引用 就是 形同虚设 ，它并不能决定 对象的生命周期。任何时候这个只有虚引用的对象都有可能被回收。因此，虚引用主要用来跟踪对象的回收，清理被销毁对象的相关资源。</p><h4 id="GC评估指标"><a href="#GC评估指标" class="headerlink" title="GC评估指标"></a>GC评估指标</h4><ul><li>吞吐量</li></ul><p>吞吐量 &#x3D; 用户运行代码的时间&#x2F;用户运行代码的时间+垃圾运行的时间  90%</p><ul><li>垃圾收集开销</li></ul><p>吞吐量补数  10%</p><ul><li>暂停时间</li></ul><p>stop the world</p><ul><li><p>收集频率</p></li><li><p>内存占用  java堆所占的空间</p></li><li><p>快速</p></li></ul><p>主要抓住两点</p><p>吞吐量和暂停时间 </p><h4 id="使用GC"><a href="#使用GC" class="headerlink" title="使用GC"></a>使用GC</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure><p>Serial GC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC</span><br></pre></td></tr></table></figure><p>年轻代 复制算法</p><p>老年代 标记整理算法</p><p><img src="/../img/image-20230409183000843.png" alt="image-20230409183000843"></p><p>ParNew GC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParNewGC</span><br><span class="line">-XX:parallelGCThreas  限制线程数量，默认开启和CPU数据相同的线程数</span><br></pre></td></tr></table></figure><p><img src="/../img/image-20230409184258518.png" alt="image-20230409184258518"></p><p>CMS</p><p>老年代回收</p><p><img src="/../img/image-20230409205702624.png" alt="image-20230409205702624"></p><p>初始标记（STW）：暂停时间非常短，标记与GC ROOT 直接关联的对象</p><p>并发标记：从GC ROOT 开始遍历整个对象图的过程</p><p>重新标记（STW）：修复并发标记环节，因为用户线程执行，导致数据的不一致问题</p><p>并发清除（耗时）：清除对象</p><p>优点</p><p>并发收集 和 低延迟</p><p>缺点</p><p>产生内存碎片 CPU敏感  产生浮动垃圾</p><p>G1</p><p>分成若干个区域</p><p>region之间是复制算法，整体看是标记压缩</p><h4 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h4><p><img src="/../img/image-20230409215948332.png" alt="image-20230409215948332"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;垃圾回收器&quot;&gt;&lt;a href=&quot;#垃圾回收器&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收器&quot;&gt;&lt;/a&gt;垃圾回收器&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;i++&lt;/code&gt;和&lt;code&gt;++i&lt;/code&gt;的区别&lt;/strong&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="JVM调优" scheme="http://duanyushuai.github.io/categories/JVM%E8%B0%83%E4%BC%98/"/>
    
    
    <category term="JVM调优" scheme="http://duanyushuai.github.io/tags/JVM%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://duanyushuai.github.io/2023/05/24/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    <id>http://duanyushuai.github.io/2023/05/24/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/</id>
    <published>2023-05-24T08:07:47.377Z</published>
    <updated>2023-05-31T03:41:03.111Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h4 id="1-聚簇索引和普通索引区别"><a href="#1-聚簇索引和普通索引区别" class="headerlink" title="1. 聚簇索引和普通索引区别"></a>1. 聚簇索引和普通索引区别</h4><p>​        聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。</p><p>在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。</p><h4 id="2-如果聚簇索引的数据更新，它的存储要不要变化"><a href="#2-如果聚簇索引的数据更新，它的存储要不要变化" class="headerlink" title="2. 如果聚簇索引的数据更新，它的存储要不要变化"></a>2. 如果聚簇索引的数据更新，它的存储要不要变化</h4><p>​       聚族索引使用一般适用自增id，聚簇索引的数据的物理存放顺序是索引顺序是一致的，即使：只要索引是相邻的，那么对应的数据一定也是相邻的存储在物理磁盘上的。如果主键不是自增ID，那么可以想象，它会干些什么，不断地调整数据的物理地址，分页，当然也有一些措施来减少这些操作，但是却无法彻底避免。但是，如果是自增的，那就简单了，它只需要一页一页的写，索引结构相对紧凑，磁盘碎片少，效率也高。</p><p>​      因此MyISAM的主索引并非聚簇索引，那么它的物理地址必然是凌乱的，拿到这些物理地址，按照合适的ID算法进行读取，于是开始不同的不停的旋转。聚簇索引则只需一次I&#x2F;O。</p><h4 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3.事务隔离级别"></a>3.事务隔离级别</h4><p>为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。</p><p>ACID  Atomicity Consistency  Isolation  Durability</p><p>**什么是幻读 **</p><ul><li>T1时刻 读取年龄为20的数据， Session1拿到了2条记录。</li><li>T2时刻 另一个进程Session2插入了一条新的记录，年龄也为20</li><li>T3时刻，Session1再次读取年龄为20的数据，发现还是2条数据，貌似 Session2新插入的数据并未影响到Session1的事务读取。</li></ul><blockquote><p>对于T1 – T3 时刻的情形，从结果来看，在可重复度读隔离级别下似乎解决了幻读的问题。</p></blockquote><ul><li>T4时刻，Session1 修改年龄为20的数据， 发现影响行数为3条。 为什么T3时候只能查到2条数据，但现在修改确修改了3条数据？</li><li>T5时刻，Session1 再次读取年龄为20的数据，发现结果变成了3条,我们知道被修改的第三条就是Session2在T2时刻新增的一条。</li></ul><blockquote><p>T4,T5 的结果来看，Session1 读到了 Session2 新插入的数据。产生了幻读现象</p></blockquote><p>​       了解过MVCC的同学，肯定知道或听说过当前读，和快照读。（不知道的同学，可以查找相关资料了解下，当然后续我也会有文章专门介绍MVCC)。首先要知道的是MVCC 就InnoDB 秒级建立数据快照的能力。 快照读就是读取数据的时候会根据一定规则读取事务可见版本的数据。 而当前读就是读取最新版本的数据。什么情况下使用的是快照读：（快照读，不会加锁）</p><blockquote><p>一般的 select * from …. where … 语句都是快照读</p></blockquote><p>什么情况下使用的是当前读：（当前读，会在搜索的时候加锁）</p><blockquote><p>select * from …. where … for update select * from …. where … lock in share mode update …. set .. where … delete from. . where ..</p></blockquote><p>如果事务中都使用快照读，那么就不会产生幻读现象，但是快照读和当前读混用就会产生幻读。</p><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><h4 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1. 缓存"></a>1. 缓存</h4><p>如果实现强一致性，不能使用缓存，我们说的这个，只是说降低概率发生，而不能完全的避免。</p><p><strong>延时双删策略</strong></p><p>在写库前后都进行 Redis 的删除操作，并且第二次删除通过延迟的方式进行</p><p>那么应该是什么样子的实现逻辑呢？</p><ul><li>第一步：先删除缓存</li><li>第二步：再写入数据库</li><li>第三步：休眠xxx毫秒（根据具体的业务时间来定）</li><li>第四步：再次删除缓存。</li></ul><p>保证缓存和数据最终一致性</p><p>**利用cannal订阅 实现 redis和mysql的数据一致性 ** </p><p>利用mysql的binlog日志，比延时双删策略要好</p><h4 id="2-分布式锁"><a href="#2-分布式锁" class="headerlink" title="2. 分布式锁"></a>2. 分布式锁</h4><p>限流  setNX</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETNX test &#x27;try&#x27;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get test</span><br><span class="line">&quot;try&quot;</span><br><span class="line">127.0.0.1:6379&gt; SETNX test &#x27;tryAgain&#x27;</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get test</span><br><span class="line">&quot;try&quot;</span><br></pre></td></tr></table></figure><h4 id="3-redis慢了怎么排查"><a href="#3-redis慢了怎么排查" class="headerlink" title="3. redis慢了怎么排查"></a>3. redis慢了怎么排查</h4><p>首先看基准运行速度，和配置相同，两台机器差值2倍以上，则是redis慢了</p><ol><li>查看redis是否使用复杂命令，Redis 提供了慢日志命令的统计功能，它记录了有哪些命令在执行时耗时比较久。</li></ol><p>可设置阈值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令执行耗时超过 5 毫秒，记录慢日志</span></span><br><span class="line">CONFIG SET slowlog-log-slower-than 5000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只保留最近 500 条慢日志</span></span><br><span class="line">CONFIG SET slowlog-max-len 500</span><br></pre></td></tr></table></figure><p>如果你的应用程序执行的 Redis 命令有以下特点，那么有可能会导致操作延迟变大： </p><ul><li>经常使用 O(N) 以上复杂度的命令，例如 SORT、SUNION、ZUNIONSTORE 聚合类命令 <strong>(建议放在客户端做)</strong></li><li>使用 O(N) 复杂度的命令，但 N 的值非常大<strong>（分批次执行）</strong></li></ul><ol start="2"><li>业务避免写入bigkey</li><li></li></ol><h2 id="JAVA基础知识"><a href="#JAVA基础知识" class="headerlink" title="JAVA基础知识"></a>JAVA基础知识</h2><h4 id="1-volatile和synchronized的区别，-问的比较细"><a href="#1-volatile和synchronized的区别，-问的比较细" class="headerlink" title="1. volatile和synchronized的区别， 问的比较细"></a>1. volatile和synchronized的区别， 问的比较细</h4><p>Volatile 实现共享变量的可见性</p><p>synchronized 还实现了原子性</p><ol><li>获得互斥锁</li><li>清空工作内存</li><li>从主内存拷贝变量的最新副本到工作的内存</li><li>执行代码</li><li>将更改后的共享变量的值刷新到主内存</li><li>释放互斥锁</li></ol><p>区别</p><ul><li>volatile不需要加锁，比synchronized更轻量级，不会阻塞线程；</li><li>从内存可见性角度，volatile读相当于加锁，volatile写相当于解锁；</li><li>synchronized既能够保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性。</li></ul><h4 id="2-线程池参数"><a href="#2-线程池参数" class="headerlink" title="2.线程池参数"></a>2.线程池参数</h4><p>核心线程数、最大线程数、空闲线程存活时间、时间单位、等待队列、拒绝策略、线程工厂</p><h4 id="3-线程安全容器有哪些"><a href="#3-线程安全容器有哪些" class="headerlink" title="3. 线程安全容器有哪些"></a>3. 线程安全容器有哪些</h4><p>HashTable<br>ConcurrentHashMap:分段<br>ArrayBlockingQueue：基于数组的有界阻塞队列</p><p>LinkedBlockingQueue：基于链表的有界阻塞队列。</p><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h4 id="1-Spring容器中的Bean是否线程安全"><a href="#1-Spring容器中的Bean是否线程安全" class="headerlink" title="1. Spring容器中的Bean是否线程安全"></a>1. Spring容器中的Bean是否线程安全</h4><p>容器本身并没有提供Bean的线程安全策略，因此可以说Spring容器中的Bean本身不具备线程安全的特性，但是具体还是要结合具体scope的Bean去研究。无状态的单例线程安全。</p><p><a href="https://repo.trojan-cdn.com/browser/spectre-whitelist.conf">https://repo.trojan-cdn.com/browser/spectre-whitelist.conf</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;Mysql&quot;&gt;&lt;a href=&quot;#Mysql&quot; class=&quot;headerlink&quot; title=&quot;Mysql&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>学习任务</title>
    <link href="http://duanyushuai.github.io/2023/05/22/%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1/"/>
    <id>http://duanyushuai.github.io/2023/05/22/%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1/</id>
    <published>2023-05-22T02:34:27.067Z</published>
    <updated>2023-05-22T13:09:04.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习任务"><a href="#学习任务" class="headerlink" title="学习任务"></a>学习任务</h1><table><thead><tr><th align="center">学习项目</th><th align="center">是否学习</th><th align="center">掌握情况</th></tr></thead><tbody><tr><td align="center">rabbitMQ</td><td align="center">是</td><td align="center">2023&#x2F;5&#x2F;22已忘 <br/></td></tr><tr><td align="center">kafka</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">jvm调优</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">mysql的索引</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Spring boot</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Spring cloud</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">docker</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;学习任务&quot;&gt;&lt;a href=&quot;#学习任务&quot; class=&quot;headerlink&quot; title=&quot;学习任务&quot;&gt;&lt;/a&gt;学习任务&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;学习项目&lt;/th&gt;
&lt;th align=&quot;cent</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://duanyushuai.github.io/2023/05/05/OSS%E5%92%8COAuth2.0/"/>
    <id>http://duanyushuai.github.io/2023/05/05/OSS%E5%92%8COAuth2.0/</id>
    <published>2023-05-05T13:14:41.991Z</published>
    <updated>2023-05-05T13:16:34.847Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h1 id="OSS和OAuth2-0"><a href="#OSS和OAuth2-0" class="headerlink" title="OSS和OAuth2.0"></a>OSS和OAuth2.0</h1><p>OSS一次登陆，多个使用</p><p>OAuth2.0 一次注册，多个登陆</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;hr&gt;
&lt;h1 id=&quot;OSS和OAuth2-0&quot;&gt;&lt;a href=&quot;#OSS和OAuth2-0&quot; class=&quot;headerlink&quot; title=&quot;OSS和OAuth2.0&quot;&gt;&lt;/a&gt;OSS和OAuth2.0&lt;/h1&gt;&lt;p&gt;OSS一次登陆，多个使用&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>nacos</title>
    <link href="http://duanyushuai.github.io/2023/04/22/nacos/"/>
    <id>http://duanyushuai.github.io/2023/04/22/nacos/</id>
    <published>2023-04-22T09:56:04.485Z</published>
    <updated>2023-04-22T09:57:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nacos"><a href="#nacos" class="headerlink" title="nacos"></a>nacos</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;nacos&quot;&gt;&lt;a href=&quot;#nacos&quot; class=&quot;headerlink&quot; title=&quot;nacos&quot;&gt;&lt;/a&gt;nacos&lt;/h1&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>sharding sphere</title>
    <link href="http://duanyushuai.github.io/2023/04/05/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>http://duanyushuai.github.io/2023/04/05/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</id>
    <published>2023-04-05T02:00:00.000Z</published>
    <updated>2023-04-05T13:29:47.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sharding-sphere"><a href="#sharding-sphere" class="headerlink" title="sharding sphere"></a>sharding sphere</h1><h3 id="分库分表应用和问题"><a href="#分库分表应用和问题" class="headerlink" title="分库分表应用和问题"></a>分库分表应用和问题</h3><ul><li>数据库设计师考虑垂直分裤，垂直分表</li><li>随着数据库数据量的增加，不要马上考虑水平切分，首先考虑缓存，读写分离，建立索引。</li><li>连接问题（分页和排序）</li><li>多数据源管理问题</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sharding-sphere&quot;&gt;&lt;a href=&quot;#sharding-sphere&quot; class=&quot;headerlink&quot; title=&quot;sharding sphere&quot;&gt;&lt;/a&gt;sharding sphere&lt;/h1&gt;&lt;h3 id=&quot;分库分表应用和问题&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="数据库" scheme="http://duanyushuai.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://duanyushuai.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JVM调优示例</title>
    <link href="http://duanyushuai.github.io/2023/03/30/jvm%E4%BC%98%E5%8C%96/"/>
    <id>http://duanyushuai.github.io/2023/03/30/jvm%E4%BC%98%E5%8C%96/</id>
    <published>2023-03-30T02:00:00.000Z</published>
    <updated>2023-04-21T10:19:27.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM调优示例"><a href="#JVM调优示例" class="headerlink" title="JVM调优示例"></a>JVM调优示例</h1><h2 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h2><p>参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails -XX:MetaspaceSize=64m</span><br><span class="line">-XX:HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=heap/heapDump.hprof</span><br><span class="line">-XX:+PrintGCDateStamps  -Xms200M  -Xmx200M  -Xloggx:log/gc-oomHeap.log</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObject</span><span class="params">()</span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;add&quot;</span>+peopleSevice);</span><br><span class="line">        ArrayList&lt;People&gt; people = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            people.add(<span class="keyword">new</span> <span class="title class_">People</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>gceasy可以分析GC日志</p><p>用工具分析dump文件 （jvisualvm）</p><h2 id="元空间溢出"><a href="#元空间溢出" class="headerlink" title="元空间溢出"></a>元空间溢出</h2><p>常量池和对类型的卸载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RequestMapping(<span class="string">&quot;/metaSpaceOom&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">metaSpaceOom</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ClassLoadingMXBean</span> <span class="variable">classLoadingMXBean</span> <span class="operator">=</span> ManagementFactory.getClassLoadingMXBean();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">            enhancer.setSuperclass(People.class);</span><br><span class="line"><span class="comment">//            enhancer.setUseCache(false);</span></span><br><span class="line">            enhancer.setUseCache(<span class="literal">true</span>);</span><br><span class="line">            enhancer.setCallback((MethodInterceptor) (o, method, objects, methodProxy) -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是加强类，输出print之前的加强方法&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> methodProxy.invokeSuper(o,objects);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> (People)enhancer.create();</span><br><span class="line">            people.print();</span><br><span class="line">            System.out.println(people.getClass());</span><br><span class="line">            System.out.println(<span class="string">&quot;totalClass:&quot;</span> + classLoadingMXBean.getTotalLoadedClassCount());</span><br><span class="line">            System.out.println(<span class="string">&quot;activeClass:&quot;</span> + classLoadingMXBean.getLoadedClassCount());</span><br><span class="line">            System.out.println(<span class="string">&quot;unloadedClass:&quot;</span> + classLoadingMXBean.getUnloadedClassCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="GC-overhead-limit-exceeded"><a href="#GC-overhead-limit-exceeded" class="headerlink" title="GC overhead limit exceeded"></a>GC overhead limit exceeded</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">               list.add(UUID.randomUUID().toString().intern());</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;************i: &quot;</span> + i);</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           <span class="keyword">throw</span> e;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">       <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">               i++;</span><br><span class="line">               str += UUID.randomUUID();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;************i: &quot;</span> + i);</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           <span class="keyword">throw</span> e;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>JDK6 新加的错误类型，一般是堆太小导致的。 98% 的时间用来做GC 回收不到2% 的内存，抛出异常</p><p>解决办法</p><p>1、有死循环，或者占大内存，优化代码</p><p>2、dump内存，检查时候有内存泄漏，加大内存</p><h2 id="线程溢出"><a href="#线程溢出" class="headerlink" title="线程溢出"></a>线程溢出</h2><p>很少遇到，调小线程栈大小</p><hr><p>JMeter 测试多线程</p><hr><p>Tomcat 配置参数</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim catalina.sh</span><br></pre></td></tr></table></figure><h4 id="1-调整堆大小，提高吞吐量"><a href="#1-调整堆大小，提高吞吐量" class="headerlink" title="1.调整堆大小，提高吞吐量"></a>1.调整堆大小，提高吞吐量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx1024m -Xms1024m </span><br></pre></td></tr></table></figure><h4 id="2-JIT编译-栈上分配"><a href="#2-JIT编译-栈上分配" class="headerlink" title="2.JIT编译 栈上分配"></a>2.JIT编译 栈上分配</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:-DoEscpeAnalysis <span class="comment">//去掉逃逸分析， 默认是开启的</span></span><br><span class="line"><span class="comment">//堆对象没有对外暴露，就在栈上分配</span></span><br><span class="line"><span class="comment">//将堆内存转为栈分配，一个对象没有逃逸出方法</span></span><br></pre></td></tr></table></figure><h4 id="3-合理配置堆内存"><a href="#3-合理配置堆内存" class="headerlink" title="3. 合理配置堆内存"></a>3. 合理配置堆内存</h4><p>分配过大，fullGC时间就会长，分配小的话，频繁fullGC</p><p>推荐设置</p><table><thead><tr><th>名称</th><th>命令</th><th>推荐设置</th></tr></thead><tbody><tr><td>Java heap</td><td>-Xms   and -Xmx</td><td>fullGC运行多次之后，看看剩余大小，在它3-4倍之间</td></tr><tr><td>元空间</td><td>-XX:PermSize      -XX:MaxPermSize</td><td>1.2倍到1.5倍之间</td></tr><tr><td>新生代</td><td>-Xmn</td><td>1-1.5</td></tr><tr><td>老年代</td><td></td><td>2-3</td></tr></tbody></table><h4 id="4-CPU过高排查方案"><a href="#4-CPU过高排查方案" class="headerlink" title="4.CPU过高排查方案"></a>4.CPU过高排查方案</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep java  查看当前java进程使用的cpu、内存和磁盘情况获取使用异常的进程</span><br><span class="line">top -Hp 进程pid  检查丹铅使用异常的线程pid</span><br><span class="line">把线程pid 换成<span class="number">16</span>进制  <span class="number">31695</span>-&gt;7bcf 得到<span class="number">0X7bc</span></span><br><span class="line">jstack 进程pid ｜ grep -A20 <span class="number">0X7bcf</span></span><br></pre></td></tr></table></figure><h4 id="5-G1并发GC线程数对性能的影响"><a href="#5-G1并发GC线程数对性能的影响" class="headerlink" title="5.G1并发GC线程数对性能的影响"></a>5.G1并发GC线程数对性能的影响</h4><p>参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX: +UserG1GC 手动指定使用G1回收器</span><br><span class="line">-XX:G1HeapRegionSize 设置每个Region大小，值是2次幂，目标根据最小的堆划分出2048个区域，默认是堆内存1/2000</span><br><span class="line">-XX:MaxGCPauseMillis 设置期望达到最大的GC停顿时间指标。默认是200ms</span><br><span class="line">-XX:ParallelGCThread 设置stw的GC线程数的值，最多8</span><br><span class="line">-XX:ConcGCThreads 设置并发编辑的线程数，将n设置为ParallelGCThread的 1/4</span><br><span class="line">-XX:InitiatingHeapOccupancyPercent 设置出发并发GC周期的java堆占用率值，超过此值就出发GC，默认45</span><br></pre></td></tr></table></figure><p>-XX:ConcGCThreads 影响吞吐量大小，建议设置1&#x2F;4</p><h4 id="6-日均百万订单JVM参数"><a href="#6-日均百万订单JVM参数" class="headerlink" title="6. 日均百万订单JVM参数"></a>6. 日均百万订单JVM参数</h4><p>日均百万订单 -&gt; 4小时产生-》 300w&#x2F;4&#x2F;3600 &#x3D; 208单&#x2F;s</p><p>按300单&#x2F;s  三台机器， 每台机器100单&#x2F;s  每台机器 4核8G</p><p>每单产生2MB对象 ，假设分给堆4G 新生代1333MB </p><p>1333M&#x2F;2M&#x2F;60 &#x3D; 11.1分钟发生一次minorGC</p><p> 因为是订单业务，可以提升新生代，进一步降低GC频率，进入老年代对象会降低，减少FUlLGC频率</p><p>业务量暴增  ，增加机器，</p><p><strong>面试题</strong></p><p>下载文件之前是1.5G堆空间，后来换了16G更慢了</p><p>FullGC时间更长</p><p>咋办</p><p>更改垃圾回收器  parallel GC ; ParNew  CMS   G1</p><p>配置GC参数  -XX:MaxGCPauseMillis  、-XX:ConcGCThreads</p><p>根据log日志和dump文件分析 ，空间占比的关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat  jinfo jstack jmap</span><br></pre></td></tr></table></figure><p>arthas可以学一下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM调优示例&quot;&gt;&lt;a href=&quot;#JVM调优示例&quot; class=&quot;headerlink&quot; title=&quot;JVM调优示例&quot;&gt;&lt;/a&gt;JVM调优示例&lt;/h1&gt;&lt;h2 id=&quot;堆溢出&quot;&gt;&lt;a href=&quot;#堆溢出&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="JVM调优" scheme="http://duanyushuai.github.io/categories/JVM%E8%B0%83%E4%BC%98/"/>
    
    
    <category term="JVM调优" scheme="http://duanyushuai.github.io/tags/JVM%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>msyql索引</title>
    <link href="http://duanyushuai.github.io/2023/03/29/mysql%E7%B4%A2%E5%BC%95/"/>
    <id>http://duanyushuai.github.io/2023/03/29/mysql%E7%B4%A2%E5%BC%95/</id>
    <published>2023-03-29T02:00:00.000Z</published>
    <updated>2023-03-30T01:14:58.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql-索引"><a href="#mysql-索引" class="headerlink" title="mysql 索引"></a>mysql 索引</h1><p>Study from <a href="https://juejin.cn/post/7147609139974242317#heading-13">https://juejin.cn/post/7147609139974242317#heading-13</a></p><h3 id="按功能逻辑层次划分"><a href="#按功能逻辑层次划分" class="headerlink" title="按功能逻辑层次划分"></a>按功能逻辑层次划分</h3><ul><li>普通索引、唯一索引、主键索引、全文索引、空间索引</li></ul><h3 id="索引创建方式"><a href="#索引创建方式" class="headerlink" title="索引创建方式"></a>索引创建方式</h3><h4 id="唯一索引创建"><a href="#唯一索引创建" class="headerlink" title="唯一索引创建"></a>唯一索引创建</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 方式①</span><br><span class="line">CREATE UNIQUE INDEX indexName ON tableName (columnName(length));</span><br><span class="line"></span><br><span class="line">-- 方式②</span><br><span class="line">ALTER TABLE tableName ADD UNIQUE INDEX indexName(columnName);</span><br><span class="line"></span><br><span class="line">-- 方式③</span><br><span class="line">CREATE TABLE tableName(  </span><br><span class="line">  columnName1 INT(8) NOT NULL,   </span><br><span class="line">  columnName2 ....,</span><br><span class="line">  .....,</span><br><span class="line">  UNIQUE INDEX [indexName] (columnName(length))  </span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="主键索引创建"><a href="#主键索引创建" class="headerlink" title="主键索引创建"></a>主键索引创建</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 方式①</span><br><span class="line">ALTER TABLE tableName ADD PRIMARY KEY indexName(columnName);</span><br><span class="line"></span><br><span class="line">-- 方式②</span><br><span class="line">CREATE TABLE tableName(  </span><br><span class="line">  columnName1 INT(8) NOT NULL,   </span><br><span class="line">  columnName2 ....,</span><br><span class="line">  .....,</span><br><span class="line">  PRIMARY KEY [indexName] (columnName(length))  </span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="全文索引创建"><a href="#全文索引创建" class="headerlink" title="全文索引创建"></a>全文索引创建</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 方式①</span><br><span class="line">ALTER TABLE tableName ADD FULLTEXT INDEX indexName(columnName);</span><br><span class="line"></span><br><span class="line">-- 方式②</span><br><span class="line">CREATE FULLTEXT INDEX indexName ON tableName(columnName);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不过在创建全文索引时，有三个注意点：</p><ul><li><code>5.6</code>版本的<code>MySQL</code>中，存储引擎必须为<code>MyISAM</code>才能创建。</li><li>创建全文索引的字段，其类型必须要为<code>CHAR、VARCHAR、TEXT</code>等文本类型。</li><li>如果想要创建出的全文索引支持中文，需要在最后指定解析器：<code>with parser ngram</code>。</li></ul><p>此时还依旧是以文章表为例，为文章名称字段创建一个全文索引，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE </span><br><span class="line">    zz_article ADD </span><br><span class="line">FULLTEXT INDEX </span><br><span class="line">    ft_article_name(article_name) </span><br><span class="line">WITH PARSER NGRAM;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+------------+--------------------------+-------------------+</span><br><span class="line">| article_id | article_name             | special_column    |</span><br><span class="line">+------------+--------------------------+-------------------+</span><br><span class="line">|          1 | MySQL架构篇：.......     | 《全解MySQL》     |</span><br><span class="line">|          2 | MySQL执行篇：.......     | 《全解MySQL》     |</span><br><span class="line">|          3 | MySQL设计篇：.......     | 《全解MySQL》     |</span><br><span class="line">|          4 | MySQL索引篇：.......     | 《全解MySQL》     |</span><br><span class="line">+------------+--------------------------+-------------------+</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">    COUNT(article_id) AS &#x27;搜索结果数量&#x27; </span><br><span class="line">FROM </span><br><span class="line">    `zz_article` </span><br><span class="line">WHERE </span><br><span class="line">    MATCH(article_name) AGAINST(&#x27;MySQL&#x27;);</span><br><span class="line"></span><br><span class="line">-- 运行结果如下：</span><br><span class="line">+--------------+</span><br><span class="line">| 搜索结果数量 |</span><br><span class="line">+--------------+</span><br><span class="line">|           4 |</span><br><span class="line">+--------------+</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE INDEX indexName ON tableName (column1(length),column2...);</span><br><span class="line">ALTER TABLE tableName ADD INDEX indexName(column1(length),column2...);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用索引正确姿势"><a href="#使用索引正确姿势" class="headerlink" title="使用索引正确姿势"></a>使用索引正确姿势</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、查询`SQL`中尽量不要使用`OR`关键字，可以使用多`SQL`或子查询代替。</span><br><span class="line"></span><br><span class="line">2、模糊查询尽量不要以`%`开头，如果实在要实现这个功能可以建立全文索引。</span><br><span class="line"></span><br><span class="line">3、编写`SQL`时一定要注意字段的数据类型，否则`MySQL`的隐式转换会导致索引失效。</span><br><span class="line"></span><br><span class="line">4、一定不要在编写`SQL`时让索引字段执行计算工作，尽量将计算工作放在客户端中完成。</span><br><span class="line"></span><br><span class="line">5、对于索引字段尽量不要使用计算类函数，一定要使用时请记得将函数计算放在`=`后面。</span><br><span class="line"></span><br><span class="line">6、多条件的查询`SQL`一定要使用联合索引中的第一个字段，否则会打破最左匹配原则。</span><br><span class="line"></span><br><span class="line">7、对于需要对比多个字段的查询业务时，可以拆分为连表查询，使用临时表代替。</span><br><span class="line"></span><br><span class="line">8、在`SQL`中不要使用反范围性的查询条件，大部分反范围性、不等性查询都会让索引失效。</span><br></pre></td></tr></table></figure><h4 id="1-索引覆盖"><a href="#1-索引覆盖" class="headerlink" title="1.索引覆盖"></a>1.索引覆盖</h4><h4 id="2-索引下推"><a href="#2-索引下推" class="headerlink" title="2.索引下推"></a>2.索引下推</h4><h4 id="3-MRR机制"><a href="#3-MRR机制" class="headerlink" title="3.MRR机制"></a>3.MRR机制</h4><p>而<code>MRR</code>机制就主要是解决这个问题的，针对于辅助索引的回表查询，减少离散<code>IO</code>，并且将随机<code>IO</code>转换为顺序<code>IO</code>，从而提高查询效率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET @@optimizer_switch=&#x27;mrr=on|off,mrr_cost_based=on|off&#x27;;</span><br></pre></td></tr></table></figure><h3 id="索引过程"><a href="#索引过程" class="headerlink" title="索引过程"></a>索引过程</h3><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>​       局部性原理的思想比较简单，比如目前有三块内存页<code>x、y、z</code>是相连的，<code>CPU</code>此刻在操作<code>x</code>页中的数据，那按照计算机的特性，一般同一个数据都会放入到物理相连的内存地址上存储，也就是当前在操作<code>x</code>页的数据，那么对于<code>y，z</code>这两页内存的数据也很有可能在接下来的时间内被操作，因此对于<code>y，z</code>这两页数据则会提前将其载入到高速缓冲区（<code>L1/L2/L3</code>），这个过程叫做利用局部性原理“预读”数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mysql-索引&quot;&gt;&lt;a href=&quot;#mysql-索引&quot; class=&quot;headerlink&quot; title=&quot;mysql 索引&quot;&gt;&lt;/a&gt;mysql 索引&lt;/h1&gt;&lt;p&gt;Study from &lt;a href=&quot;https://juejin.cn/post/714</summary>
      
    
    
    
    <category term="索引" scheme="http://duanyushuai.github.io/categories/%E7%B4%A2%E5%BC%95/"/>
    
    
    <category term="索引" scheme="http://duanyushuai.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>java各种变量</title>
    <link href="http://duanyushuai.github.io/2023/03/02/java%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>http://duanyushuai.github.io/2023/03/02/java%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</id>
    <published>2023-03-02T02:00:00.000Z</published>
    <updated>2023-03-03T01:17:19.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java各种变量"><a href="#java各种变量" class="headerlink" title="java各种变量"></a>java各种变量</h1><h3 id="java-jar-配置参数写法说明"><a href="#java-jar-配置参数写法说明" class="headerlink" title="java -jar 配置参数写法说明"></a>java -jar 配置参数写法说明</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -Dxxx=test  -jar xxx.jar  （放在-jar之前）</span><br><span class="line">取值： System.getProperty(&quot;xxx&quot;)</span><br><span class="line">      spring的@value(&quot;$&#123;xxx&#125;&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxx.jar value1=1 value2=2  （放在启动jar包之后）</span><br><span class="line">参数就是jar包里主启动类中main方法的args参数，按顺序来</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SpringBoot项目写法 </span><br><span class="line">java -jar xxx.jar --xxx=test（放在启动jar包之后）</span><br><span class="line">取值：spring的@value(&quot;$&#123;xxx&#125;&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java各种变量&quot;&gt;&lt;a href=&quot;#java各种变量&quot; class=&quot;headerlink&quot; title=&quot;java各种变量&quot;&gt;&lt;/a&gt;java各种变量&lt;/h1&gt;&lt;h3 id=&quot;java-jar-配置参数写法说明&quot;&gt;&lt;a href=&quot;#java-jar-配置参</summary>
      
    
    
    
    <category term="java各种变量" scheme="http://duanyushuai.github.io/categories/java%E5%90%84%E7%A7%8D%E5%8F%98%E9%87%8F/"/>
    
    
    <category term="java各种变量" scheme="http://duanyushuai.github.io/tags/java%E5%90%84%E7%A7%8D%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>dockerfile 编写</title>
    <link href="http://duanyushuai.github.io/2023/03/01/dockerfile%E7%BC%96%E5%86%99/"/>
    <id>http://duanyushuai.github.io/2023/03/01/dockerfile%E7%BC%96%E5%86%99/</id>
    <published>2023-03-01T03:00:23.000Z</published>
    <updated>2023-03-03T07:14:45.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dockerfile-编写"><a href="#dockerfile-编写" class="headerlink" title="dockerfile 编写"></a>dockerfile 编写</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&#x27;duanyushuai&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">adv=dev\</span></span><br><span class="line"><span class="language-bash">aab=fff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行的命令，安装了软件，修改了文件，默认用id=0 也就是root</span></span><br><span class="line"><span class="comment">#镜像构建运行的命令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> 111</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> ping baidu.com </span></span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> 命令</span></span><br><span class="line"><span class="comment"># shell 形式 bash -c &quot;echo 111&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> 1111</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;echo&quot;</span>,<span class="string">&quot;2222&quot;</span>]</span></span><br></pre></td></tr></table></figure><h3 id="ARG-和-ENV"><a href="#ARG-和-ENV" class="headerlink" title="ARG 和 ENV"></a>ARG 和 ENV</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定构建参数有效</span></span><br><span class="line"><span class="keyword">ARG</span> aaa =aaa</span><br><span class="line"><span class="comment"># 指定环境变量[为RUN以及CMD指定环境变量的]</span></span><br><span class="line"><span class="keyword">ENV</span> parm=<span class="number">1111</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="variable">$parm</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;echo&quot;</span>,<span class="string">&quot;<span class="variable">$parm</span>&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">sleep</span> 10; <span class="built_in">echo</span> <span class="variable">$parm</span></span></span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> version=<span class="number">1.3</span>.<span class="number">0</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:$version</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以用命令替换参数</span></span><br><span class="line">docker build --no-cache  --build-<span class="keyword">arg</span> version=<span class="string">&quot;1.55.4&quot;</span>  -t  [镜像名]：[镜像版本]  -f dockerfile .</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> app=duan</span><br><span class="line"></span><br><span class="line"><span class="comment">#构建期和运行期都可以生效，但只能在运行期修改</span></span><br><span class="line"></span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -e app=haha </span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">ENV</span> 的坑</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> msg1=hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> msg2=$&#123;msg1&#125;</span><br><span class="line"></span><br><span class="line">echo $&#123;msg1&#125;</span><br><span class="line">echo $&#123;msg2&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;echo <span class="variable">$&#123;msg1&#125;</span>;echo <span class="variable">$&#123;msg2&#125;</span>&quot;</span>]</span></span><br><span class="line"></span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -it e msg1=666 </span></span><br><span class="line"><span class="comment">#输出的是666 hello </span></span><br><span class="line"><span class="comment">#原因是docker build 的时候，env的指已经写好了 msg1=hello。msg2 = hello</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ADD-和COPY"><a href="#ADD-和COPY" class="headerlink" title="ADD 和COPY"></a>ADD 和COPY</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 把上下文的内容复制到镜像中，如果是压缩包自动解压，如果是远程自动下载</span></span><br><span class="line"><span class="comment">#自动下载</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> https://download.redis.io/releases/redis-6.2.1.tar.gz  /dest/    <span class="comment">#不加最后斜杠变为dest文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">#RUN指令并没有上下文关系 不能RUN cd /dest RUN ls -l</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /dest &amp;&amp; <span class="built_in">ls</span> -l</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#宿主机到镜像 自动解压 </span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> *.tar.gz  /app/ </span></span><br><span class="line"></span><br><span class="line">不自动解压</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash">  </span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="WORKDIR-和VOLUME"><a href="#WORKDIR-和VOLUME" class="headerlink" title="WORKDIR 和VOLUME"></a>WORKDIR 和VOLUME</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 为一下所有的命令运行指定了基础目录</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">WORKDIR</span><span class="language-bash"> abc 可以嵌套</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment"># pwd &amp;&amp; ls -l</span></span><br><span class="line"> <span class="keyword">RUN</span><span class="language-bash">  <span class="built_in">pwd</span> &amp;&amp; <span class="built_in">ls</span> -l</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">#-----------------------------</span></span><br><span class="line"> <span class="comment">#挂载容器内文件 ，没有就创建</span></span><br><span class="line"> <span class="comment">#指定了VOLUME，即使启动容器没有指定 -v 参数，我们也会自动进行匿名卷挂载</span></span><br><span class="line"> VOLUM [<span class="string">&quot;/hello&quot;</span>,<span class="string">&quot;/app&quot;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /hello &amp;&amp; <span class="built_in">mkdir</span> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> 111 &gt; /hello/a.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> 222 &gt; /app/b.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#挂载之后</span></span><br><span class="line"><span class="comment"># 1）但是docker commit 提交当前容器的所有变化为镜像的时候，就会丢弃</span></span><br><span class="line"><span class="comment"># 2）VOLUME [&quot;/hello&quot;,&quot;/app&quot;] 容器以后自动挂载，在dockerfile中对VOLUME的所有修改都不生效</span></span><br><span class="line"><span class="comment"># 3）建议VOLUME 写在最后面</span></span><br><span class="line">VOUME [<span class="string">&quot;/hello&quot;</span>,<span class="string">&quot;/app&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这两句话没有生效</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> 4444 &gt;&gt; /hello/a.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> 4444 &gt;&gt; /app/b.txt</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#暴露，只是一个声明，给程序员看的</span></span><br><span class="line"><span class="comment"># 给docker 看的 -d -P（随机分配端口）</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><h3 id="CMD-和-ENTRYPOINT"><a href="#CMD-和-ENTRYPOINT" class="headerlink" title="CMD 和 ENTRYPOINT"></a>CMD 和 ENTRYPOINT</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统一是容器启动命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#官方推荐写法，变化的写CMD，而CMD提供的参数给ENTRPOINT使用的</span></span><br><span class="line"><span class="comment"># docker run imageName cmd1 一旦传递了cmd1，CMD指定的所有参数都会被覆盖。</span></span><br><span class="line"><span class="comment">#自定义参数一定要写全</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;5&quot;</span>,<span class="string">&quot;baidu.com&quot;</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;ping&quot;</span>,<span class="string">&quot;-c&quot;</span>]</span></span><br></pre></td></tr></table></figure><h3 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> maven:<span class="number">3.5</span>.<span class="number">0</span>-jdk-<span class="number">8</span>-alpine AS builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">add</span><span class="language-bash"> ./ /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二阶段，最小运行环境只需要jre</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jre-alpine</span><br><span class="line"><span class="comment"># 修改时区 </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span> &gt;/etc/timezone</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer = <span class="string">&quot;duanyushuai&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">#从上一个阶段复制内容</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --frombuilder /app/target/*.jar /app/jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#docker run -e JAVA_OPTS=&quot;-Xmx512m -Xms33 &quot; -e PARAM=&quot;--spring.profiles=dev&quot; -jar app.jar</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_OPTS=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PARAMS=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;java -Djava.security.egd=file:/dev/./urandom <span class="variable">$JAVA_OPTS</span> -jar /app.jar <span class="variable">$PARAMS</span>&quot;</span>]</span></span><br></pre></td></tr></table></figure><h3 id="springboot-dockerfile常用写法"><a href="#springboot-dockerfile常用写法" class="headerlink" title="springboot dockerfile常用写法"></a>springboot dockerfile常用写法</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jre-aalpine</span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;duanyushuai&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> target/*.jar  /app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span> &gt;/etc/timezone &amp;&amp; <span class="built_in">touch</span> /app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> JAVA_OPTS=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PARAMS=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;java -Djava.security.egd=file:/dev/./urandom <span class="variable">$JAVA_OPTS</span> -jar /app.jar <span class="variable">$PARAMS</span>&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;dockerfile-编写&quot;&gt;&lt;a href=&quot;#dockerfile-编写&quot; class=&quot;headerlink&quot; title=&quot;dockerfile 编写&quot;&gt;&lt;/a&gt;dockerfile 编写&lt;/h1&gt;&lt;figure class=&quot;highlight dock</summary>
      
    
    
    
    <category term="docker" scheme="http://duanyushuai.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="http://duanyushuai.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>msyql性能优化</title>
    <link href="http://duanyushuai.github.io/2023/03/01/mysql%E4%BC%98%E5%8C%96/"/>
    <id>http://duanyushuai.github.io/2023/03/01/mysql%E4%BC%98%E5%8C%96/</id>
    <published>2023-03-01T02:00:00.000Z</published>
    <updated>2023-03-31T07:35:51.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="msyql性能优化"><a href="#msyql性能优化" class="headerlink" title="msyql性能优化"></a>msyql性能优化</h1><h2 id="1-系统配置优化"><a href="#1-系统配置优化" class="headerlink" title="1.系统配置优化"></a>1.系统配置优化</h2><h4 id="1-1-内存读取数据"><a href="#1-1-内存读取数据" class="headerlink" title="1.1  内存读取数据"></a>1.1  内存读取数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调大 innodb_buffer_pool_size</span><br></pre></td></tr></table></figure><h4 id="1-2-数据预热"><a href="#1-2-数据预热" class="headerlink" title="1.2 数据预热"></a>1.2 数据预热</h4><p>默认情况，仅仅有某条数据被读取一次，才会缓存在 innodb_buffer_pool。所以，数据库刚刚启动，须要进行数据预热，将磁盘上的全部数据缓存到内存中。数据预热能够提高读取速度。</p><h4 id="1-3降低磁盘写入"><a href="#1-3降低磁盘写入" class="headerlink" title="1.3降低磁盘写入"></a>1.3降低磁盘写入</h4><p>1.增大redolog，减少落盘次数</p><p>innodb_log_file_size 设置为 0.25 * innodb_buffer_pool_size</p><p>2.通用查询日志、慢查询日志可以不开 ，bin-log开</p><p>生产中不开通用查询日志，遇到性能问题开慢查询日志</p><h2 id="2-表结构优化"><a href="#2-表结构优化" class="headerlink" title="2. 表结构优化"></a>2. 表结构优化</h2><h4 id="2-1-设计中间表"><a href="#2-1-设计中间表" class="headerlink" title="2.1 设计中间表"></a>2.1 设计中间表</h4><h4 id="2-2-设计冗余字段"><a href="#2-2-设计冗余字段" class="headerlink" title="2.2 设计冗余字段"></a>2.2 设计冗余字段</h4><h4 id="2-3拆表"><a href="#2-3拆表" class="headerlink" title="2.3拆表"></a>2.3拆表</h4><p>对于表中经常不被使用的字段或者存储数据比较多的字段，考虑拆表</p><h4 id="2-5-字段的设计"><a href="#2-5-字段的设计" class="headerlink" title="2.5 字段的设计"></a><strong>2.5</strong> 字段的设计</h4><p>字段宽度尽可能小，尽量把字段设置为NOTNULL，能用数字的用数值类型</p><h2 id="3-sql语句，索引优化"><a href="#3-sql语句，索引优化" class="headerlink" title="3. sql语句，索引优化"></a>3. sql语句，索引优化</h2><h4 id="3-1-EXPLAIN-查看索引使用情况"><a href="#3-1-EXPLAIN-查看索引使用情况" class="headerlink" title="3.1 EXPLAIN 查看索引使用情况"></a>3.1 EXPLAIN 查看索引使用情况</h4><h4 id="3-2-SQL语句中-IN-包含的值不应过多"><a href="#3-2-SQL语句中-IN-包含的值不应过多" class="headerlink" title="3.2 SQL语句中 IN 包含的值不应过多"></a>3.2 SQL语句中 IN 包含的值不应过多</h4><h4 id="3-3-SELECT-语句务必指明字段名称"><a href="#3-3-SELECT-语句务必指明字段名称" class="headerlink" title="3.3 SELECT 语句务必指明字段名称"></a>3.3 SELECT 语句务必指明字段名称</h4><h4 id="3-4-当只需要一条数据的时候，使用-limit-1"><a href="#3-4-当只需要一条数据的时候，使用-limit-1" class="headerlink" title="3.4 当只需要一条数据的时候，使用  limit 1"></a><strong>3.4</strong> 当只需要一条数据的时候，使用  limit 1</h4><h4 id="3-5-排序字段加索引"><a href="#3-5-排序字段加索引" class="headerlink" title="3.5  排序字段加索引"></a>3.5  排序字段加索引</h4><h4 id="3-6-不使用ORDER-BY-RAND"><a href="#3-6-不使用ORDER-BY-RAND" class="headerlink" title="3.6 不使用ORDER BY RAND()"></a>3.6 不使用ORDER BY RAND()</h4><h4 id="3-7-如果限制条件中其他字段没有索引，尽量少用-or"><a href="#3-7-如果限制条件中其他字段没有索引，尽量少用-or" class="headerlink" title="3.7 如果限制条件中其他字段没有索引，尽量少用 or"></a>3.7 如果限制条件中其他字段没有索引，尽量少用 or</h4><h4 id="3-8-区分in-和exists、not-in和not-exists"><a href="#3-8-区分in-和exists、not-in和not-exists" class="headerlink" title="3.8 区分in 和exists、not in和not exists"></a>3.8 区分in 和exists、not in和not exists</h4><p>区分in和exists主要是造成了驱动顺序的改变（这是性能变化的关键），如果是exists，那么以外层表为</p><p>驱动表，先被访问，如果是IN，那么先执行子查询。所以IN适合于外表大而内表小的情况；EXISTS适合</p><p>于外表小而内表大的情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from tbiguser limit 9999998, 2;</span><br><span class="line">select * from tbiguser where id&gt;9999998 limit 2;</span><br></pre></td></tr></table></figure><h4 id="3-9不建议使用-前缀模糊查询"><a href="#3-9不建议使用-前缀模糊查询" class="headerlink" title="3.9不建议使用%前缀模糊查询"></a>3.9不建议使用%前缀模糊查询</h4><h4 id="3-10避免在where子句中对字段进行表达式操作"><a href="#3-10避免在where子句中对字段进行表达式操作" class="headerlink" title="3.10避免在where子句中对字段进行表达式操作"></a>3.10避免在where子句中对字段进行表达式操作</h4><h4 id="3-11避免隐式类型转换"><a href="#3-11避免隐式类型转换" class="headerlink" title="3.11避免隐式类型转换"></a>3.11避免隐式类型转换</h4><h4 id="3-12对于联合索引来说，要遵守最左前缀法则"><a href="#3-12对于联合索引来说，要遵守最左前缀法则" class="headerlink" title="3.12对于联合索引来说，要遵守最左前缀法则"></a>3.12对于联合索引来说，要遵守最左前缀法则</h4><h4 id="3-13-使用JOIN-优化，尽量选择少表作为驱动表"><a href="#3-13-使用JOIN-优化，尽量选择少表作为驱动表" class="headerlink" title="3.13 使用JOIN 优化，尽量选择少表作为驱动表"></a>3.13 使用JOIN 优化，尽量选择少表作为驱动表</h4><h2 id="4-explain使用"><a href="#4-explain使用" class="headerlink" title="4.explain使用"></a>4.explain使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----+-------------+----------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">| id | select_type | table    | type | possible_keys | key  | key_len | ref  | rows | Extra |</span><br><span class="line">+----+-------------+----------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | zz_users | ALL  | NULL          | NULL | NULL    | NULL |    3 |       |</span><br><span class="line">+----+-------------+----------+------+---------------+------+---------+------+------+-------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>id</code>：这是执行计划的<code>ID</code>值，这个值越大，表示执行的优先级越高。</p><p><code>select_type</code>：当前查询语句的类型，有如下几个值：</p><ul><li><code>simple</code>：简单查询。</li><li><code>primary</code>：复杂查询的外层查询。</li><li><code>subquery</code>：包含在查询语句中的子查询。</li><li><code>derived</code>：包含在<code>FROM</code>中的子查询。</li></ul><p><code>table</code>：表示当前这个执行计划是基于那张表执行的。</p><p><code>type</code>：当前执行计划查询的类型，有几种情况：</p><ul><li><code>all</code>：表示走了全表查询，未命中索引或索引失效。</li><li><code>system</code>：表示要查询的表中仅有一条数据。</li><li><code>const</code>：表示当前<code>SQL</code>语句的查询条件中，可以命中索引查询。</li><li><code>range</code>：表示当前查询操作是查某个区间。</li><li><code>eq_ref</code>：表示目前在做多表关联查询。</li><li><code>ref</code>：表示目前使用了普通索引查询。</li><li><code>index</code>：表示目前<code>SQL</code>使用了辅助索引查询。</li></ul><p><code>possible_keys</code>：执行<code>SQL</code>时，优化器可能会选择的索引（最后执行不一定用）。</p><p><code>key</code>：查询语句执行时，用到的索引名字。</p><p><code>key_len</code>：这里表示索引字段使用的字节数。</p><p><code>ref</code>：这里显示使用了那种查询的类型。</p><p><code>rows</code>：当前查询语句可能会扫描多少行数据才能检索出结果。</p><p><code>Extra</code>：这里是记录着额外的一些索引使用信息，有几种状态：</p><ul><li><code>using index</code>：表示目前使用了覆盖索引查询（稍后讲）。</li><li><code>using where</code>：表示使用了<code>where</code>子句查询，通常表示没使用索引。</li><li><code>using index condition</code>：表示查询条件使用到了联合索引的前面几个字段。</li><li><code>using temporary</code>：表示使用了临时表处理查询结果。</li><li><code>using filesort</code>：表示以索引字段之外的方式进行排序，效率较低。</li><li><code>select tables optimized away</code>：表示在索引字段上使用了聚合函数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create table tbiguser(</span><br><span class="line">  id int primary key auto_increment, </span><br><span class="line">  nickname varchar(255), </span><br><span class="line">  loginname varchar(255), </span><br><span class="line">  age int, </span><br><span class="line">  sex char(1), </span><br><span class="line">  status int, </span><br><span class="line">  address varchar(255)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table tuser2( id int primary key auto_increment, name varchar(255), address varchar(255) );</span><br></pre></td></tr></table></figure><h5 id="1-无变化"><a href="#1-无变化" class="headerlink" title="1.无变化"></a>1.无变化</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT</span><br><span class="line">count( id ) num,</span><br><span class="line">address </span><br><span class="line">FROM</span><br><span class="line">tbiguser </span><br><span class="line">WHERE</span><br><span class="line">address IN ( SELECT DISTINCT address FROM tuser1 ) </span><br><span class="line">GROUP BY</span><br><span class="line">address </span><br><span class="line">UNION</span><br><span class="line">SELECT</span><br><span class="line">count( id ) num,</span><br><span class="line">address </span><br><span class="line">FROM</span><br><span class="line">tbiguser </span><br><span class="line">WHERE</span><br><span class="line">address IN ( SELECT DISTINCT address FROM tuser2 ) </span><br><span class="line">GROUP BY</span><br><span class="line">address</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2dongbei</span><br><span class="line">1xianggang</span><br><span class="line">1shanghai</span><br></pre></td></tr></table></figure><p><img src="/../img/mysql%E4%BC%98%E5%8C%961.jpeg"></p><h5 id="2-给address加索引"><a href="#2-给address加索引" class="headerlink" title="2. 给address加索引"></a>2. 给address加索引</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table tbiguser add index idx_addr(address);</span><br><span class="line">alter table tuser1 add index idx_addr(address); </span><br><span class="line">alter table tuser2 add index idx_addr(address);</span><br></pre></td></tr></table></figure><p><img src="/../img/mysql%E4%BC%98%E5%8C%962.jpeg"></p><h5 id="3-修改sql"><a href="#3-修改sql" class="headerlink" title="3. 修改sql"></a>3. 修改sql</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT</span><br><span class="line">count( id ) num,</span><br><span class="line">address </span><br><span class="line">FROM</span><br><span class="line">tbiguser </span><br><span class="line">WHERE</span><br><span class="line">address IN ( SELECT DISTINCT address FROM tuser1 ) </span><br><span class="line">OR address IN ( SELECT DISTINCT address FROM tuser2 ) </span><br><span class="line">GROUP BY</span><br><span class="line">address </span><br><span class="line">ORDER BY</span><br><span class="line">address;</span><br></pre></td></tr></table></figure><p><img src="/../img/mysql%E4%BC%98%E5%8C%963.jpeg"></p><p>4. </p><p>从前面的执行计划可以看出，索引只是使用了覆盖索引，rows&#x3D;9754360， 说明还是几乎扫描了全表的</p><p>行</p><p>利用address索引，先过滤数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select distinct b.* from tuser2 a,tbiguser b where a.address=b.address;</span><br><span class="line">select distinct b.* from tuser1 a,tbiguser b where a.address=b.address;</span><br></pre></td></tr></table></figure><p>创建视图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create view v_tuser as select distinct b.* from tuser1 a,tbiguser b where a.address=b.address union all select distinct b.* from tuser2 a,tbiguser b where a.address=b.address;</span><br><span class="line">--执行SQL </span><br><span class="line">select count(id) cont ,address from v_tuser group by address order by address;</span><br></pre></td></tr></table></figure><h3 id="优化总结"><a href="#优化总结" class="headerlink" title="优化总结"></a>优化总结</h3><p>开启慢查询日志，定位运行慢的SQL语句</p><p>利用explain执行计划，查看SQL执行情况</p><p>关注索引使用情况：type</p><p>关注Rows：行扫描</p><p>关注Extra：没有信息最好</p><p>加索引后，查看索引使用情况，index只是覆盖索引，并不算很好的使用索引</p><p>如果有关联尽量将索引用到<strong>eq_ref</strong>或<strong>ref</strong>级别</p><p>复杂SQL可以做成视图，视图在MySQL内部有优化，而且开发也比较友好</p><p>对于复杂的SQL要逐一分析，找到比较费时的SQL语句片段进行优化</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;msyql性能优化&quot;&gt;&lt;a href=&quot;#msyql性能优化&quot; class=&quot;headerlink&quot; title=&quot;msyql性能优化&quot;&gt;&lt;/a&gt;msyql性能优化&lt;/h1&gt;&lt;h2 id=&quot;1-系统配置优化&quot;&gt;&lt;a href=&quot;#1-系统配置优化&quot; class=&quot;</summary>
      
    
    
    
    <category term="msyql" scheme="http://duanyushuai.github.io/categories/msyql/"/>
    
    
    <category term="msyql" scheme="http://duanyushuai.github.io/tags/msyql/"/>
    
  </entry>
  
  <entry>
    <title>k8s</title>
    <link href="http://duanyushuai.github.io/2023/02/22/k8s/"/>
    <id>http://duanyushuai.github.io/2023/02/22/k8s/</id>
    <published>2023-02-22T06:14:11.674Z</published>
    <updated>2023-04-24T13:35:29.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod  </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;k8s&quot;&gt;&lt;a href=&quot;#k8s&quot; class=&quot;headerlink&quot; title=&quot;k8s&quot;&gt;&lt;/a&gt;k8s&lt;/h1&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>常用linux命令</title>
    <link href="http://duanyushuai.github.io/2023/02/10/linux/"/>
    <id>http://duanyushuai.github.io/2023/02/10/linux/</id>
    <published>2023-02-10T01:50:08.054Z</published>
    <updated>2023-03-02T13:50:40.581Z</updated>
    
    <content type="html"><![CDATA[<p><strong>查找文件名中包含某字符（如”elm”）的文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home/lijiajia/ -name <span class="string">&#x27;*elm*&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>删除目录</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /root/logs/game </span><br></pre></td></tr></table></figure><p><strong>删除文件夹</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f /root/logs/game </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;查找文件名中包含某字符（如”elm”）的文件&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>netty学习</title>
    <link href="http://duanyushuai.github.io/2023/01/30/netty%E7%AC%94%E8%AE%B0/"/>
    <id>http://duanyushuai.github.io/2023/01/30/netty%E7%AC%94%E8%AE%B0/</id>
    <published>2023-01-30T13:33:46.509Z</published>
    <updated>2023-02-05T13:55:27.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="netty-笔记"><a href="#netty-笔记" class="headerlink" title="netty 笔记"></a>netty 笔记</h1><h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><p>传统IO，从直接内存DMA 拷贝到内核 在用CPU拷贝到用户态进行修改，在用cpu拷贝内核，在DMA拷贝到协议栈</p><p>mmap优化</p><p>通过内存映射，用户空间可以共享内核空间数据。</p><p>零拷贝指没有cpu拷贝   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;netty-笔记&quot;&gt;&lt;a href=&quot;#netty-笔记&quot; class=&quot;headerlink&quot; title=&quot;netty 笔记&quot;&gt;&lt;/a&gt;netty 笔记&lt;/h1&gt;&lt;h4 id=&quot;零拷贝&quot;&gt;&lt;a href=&quot;#零拷贝&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Ruoyi-pro 随记</title>
    <link href="http://duanyushuai.github.io/2023/01/22/%E8%8B%A5%E4%BE%9D%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    <id>http://duanyushuai.github.io/2023/01/22/%E8%8B%A5%E4%BE%9D%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-01-22T02:00:00.000Z</published>
    <updated>2023-04-25T09:29:20.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ruoyi-pro-随记"><a href="#Ruoyi-pro-随记" class="headerlink" title="Ruoyi-pro 随记"></a>Ruoyi-pro 随记</h1><h3 id="1-Scheduled注解"><a href="#1-Scheduled注解" class="headerlink" title="1.@Scheduled注解"></a>1.@Scheduled注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(fixedDelay = 60*1000, initialDelay = 60*1000)</span></span><br></pre></td></tr></table></figure><p><code>fixedDelay</code>: 它的间隔时间是根据上次的任务结束的时候开始计时的。比如一个方法上设置了fixedDelay&#x3D;5*1000，那么当该方法某一次执行结束后，开始计算时间，当时间达到60秒，就开始再次执行该方法。</p><p><code>initialDelay</code>: 容器启动后60s执行一次</p><h3 id="2-EventListene-注解"><a href="#2-EventListene-注解" class="headerlink" title="2. @EventListene 注解"></a>2. @EventListene 注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener(ApplicationReadyEvent.class)</span></span><br></pre></td></tr></table></figure><p><strong>延伸</strong></p><p>容器启动时候执行方法</p><p><code>@PostConstruct</code>  存在的问题是如果执行的方法耗时过长，会导致项目在方法执行期间无法提供服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StartInit</span> &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    @Autowired   可以注入bean</span></span><br><span class="line"><span class="comment">//    ISysUserService userService;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10</span>*<span class="number">1000</span>);<span class="comment">//这里如果方法执行过长会导致项目一直无法提供服务</span></span><br><span class="line">        System.out.println(<span class="number">123456</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ApplicationReadyEvent"><a href="#ApplicationReadyEvent" class="headerlink" title="ApplicationReadyEvent"></a>ApplicationReadyEvent</h4><p>再注册一个 <code>CommandLineRunner</code> 类, 在这个 runner 类中将这个公共 int 值自增一次</p><p>再添加一个 <code>ApplicationStartedEvent</code> 事件的监听者，触发时打印出这个公共 int 值</p><p>再添加一个 <code>ApplicationReadyEvent</code> 事件的监听者，触发时打印出这个公共 int 值</p><p>运行这个 <code>SpringBoot</code> 程序，那么：</p><ul><li><code>ApplicationStartedEvent</code> 事件的监听者打印出来的 int 值是 <code>1</code></li><li>这个 <code>CommandLineRunner</code> 类看到的 int 值是 1，将其自增 <code>1</code></li><li><code>ApplicationReadyEvent</code> 事件的监听者打印出来的 int 值是 <code>2</code></li></ul><h3 id="3-Async注解"><a href="#3-Async注解" class="headerlink" title="3. @Async注解"></a>3. @Async注解</h3><p>创建一个线程执行</p><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ruoyi-pro-随记&quot;&gt;&lt;a href=&quot;#Ruoyi-pro-随记&quot; class=&quot;headerlink&quot; title=&quot;Ruoyi-pro 随记&quot;&gt;&lt;/a&gt;Ruoyi-pro 随记&lt;/h1&gt;&lt;h3 id=&quot;1-Scheduled注解&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="开源框架学习" scheme="http://duanyushuai.github.io/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="开源框架学习" scheme="http://duanyushuai.github.io/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>动态线程池</title>
    <link href="http://duanyushuai.github.io/2023/01/13/%E5%8A%A8%E6%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://duanyushuai.github.io/2023/01/13/%E5%8A%A8%E6%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2023-01-13T02:00:00.000Z</published>
    <updated>2023-03-01T02:12:27.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态线程池"><a href="#动态线程池" class="headerlink" title="动态线程池"></a>动态线程池</h1><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html</a></p><p><a href="https://mp.weixin.qq.com/s/leoP_3uOtXsE55PMmSAVTg">https://mp.weixin.qq.com/s/leoP_3uOtXsE55PMmSAVTg</a></p><p><a href="https://mp.weixin.qq.com/s/4kir2LfMnyuApKwulnRAmA">https://mp.weixin.qq.com/s/4kir2LfMnyuApKwulnRAmA</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态线程池&quot;&gt;&lt;a href=&quot;#动态线程池&quot; class=&quot;headerlink&quot; title=&quot;动态线程池&quot;&gt;&lt;/a&gt;动态线程池&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://tech.meituan.com/2020/04/02/java-pooling-</summary>
      
    
    
    
    <category term="线程" scheme="http://duanyushuai.github.io/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="多线程" scheme="http://duanyushuai.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>springboot源码</title>
    <link href="http://duanyushuai.github.io/2023/01/10/springboot%E6%BA%90%E7%A0%81/"/>
    <id>http://duanyushuai.github.io/2023/01/10/springboot%E6%BA%90%E7%A0%81/</id>
    <published>2023-01-10T12:00:00.000Z</published>
    <updated>2023-01-11T08:39:23.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Springboot源码"><a href="#Springboot源码" class="headerlink" title="Springboot源码"></a>Springboot源码</h1><p><code>@springbootApplication</code>注解包括</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;Registrar.class&#125;)</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br></pre></td></tr></table></figure><p><code>@Import(&#123;Registrar.class&#125;) </code>指定我们要扫描哪些包下组件</p><p><code>AutoConfigurationPackages</code>怎么创建对象的，就是<code>controller</code>等对象创建</p><p><code>@Import(&#123;AutoConfigurationImportSelector.class&#125;) </code> 中加载<code>classLoader.getResources(&quot;META-INF/spring.factories&quot;)</code></p><p>SPI机制 找到<code>@EnableAutoConfiguration</code>中全类名对应的值</p><p><img src="/../img/springboot%E6%BA%90%E7%A0%811.jpg"></p><p>有过滤组件，引入了包，自动配置才生效</p><p><code>Spring</code> 启动器 <code>springmvc</code>启动器</p><p>1.首先先启动<code>ServletWebServerFactoryAutoConfiguration</code>   servlet容器</p><p>2.在启动<code>DispatcherServletAutoConfiguration</code></p><h5 id="1-ServletWebServerFactoryAutoConfiguration"><a href="#1-ServletWebServerFactoryAutoConfiguration" class="headerlink" title="1. ServletWebServerFactoryAutoConfiguration"></a>1. ServletWebServerFactoryAutoConfiguration</h5><p><code>@EnableConfigurationProperties(ServlerProperties.class)</code>   </p><p>配置tomcat参数</p><p><code>@Import   WebServerFactoryCustomizerBeanPostProcessor</code></p><p>导入三种服务器 Tomcat 、jetty、Undertow 默认是Tomcat生效  </p><p>给容器中放入<code>TomcatServeletWebServerFactory </code>      </p><p><code>@ConditionalOnMissingBean(ServletWebServerFactory) </code>我们也可以自己放一个<code>ServletWebServerFactory</code></p><p>TomcatServeletWebServerFactory 里的getWebServer 创建new Tomcat() </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Springboot源码&quot;&gt;&lt;a href=&quot;#Springboot源码&quot; class=&quot;headerlink&quot; title=&quot;Springboot源码&quot;&gt;&lt;/a&gt;Springboot源码&lt;/h1&gt;&lt;p&gt;&lt;code&gt;@springbootApplication&lt;/</summary>
      
    
    
    
    <category term="springboot" scheme="http://duanyushuai.github.io/categories/springboot/"/>
    
    
    <category term="源码" scheme="http://duanyushuai.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>caffeine 本地缓存</title>
    <link href="http://duanyushuai.github.io/2023/01/10/Caffeine%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/"/>
    <id>http://duanyushuai.github.io/2023/01/10/Caffeine%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/</id>
    <published>2023-01-10T06:00:00.000Z</published>
    <updated>2023-01-11T01:23:04.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="caffeine-本地缓存"><a href="#caffeine-本地缓存" class="headerlink" title="caffeine 本地缓存"></a>caffeine 本地缓存</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;caffeine&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.9</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>官方文档 ：<a href="https://github.com/ben-manes/caffeine/wiki/Eviction-zh-CN">https://github.com/ben-manes/caffeine/wiki/Eviction-zh-CN</a></p><h4 id="添加-3种加载策略"><a href="#添加-3种加载策略" class="headerlink" title="添加    3种加载策略"></a>添加    3种加载策略</h4><p><strong>手动加载</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> duan.test.caffeine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Caffeine;</span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.LoadingCache;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaffeineTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="comment">// 初始化缓存，设置了1分钟的写过期，100的缓存最大个数</span></span><br><span class="line">            Cache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                    .expireAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">                    .maximumSize(<span class="number">100</span>)</span><br><span class="line">                    .build();</span><br><span class="line">            <span class="type">int</span> <span class="variable">key1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 使用getIfPresent方法从缓存中获取值。如果缓存中不存指定的值，则方法将返回 null：</span></span><br><span class="line">            System.out.println(cache.getIfPresent(key1));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 也可以使用 get 方法获取值，该方法将一个参数为 key 的 Function 作为参数传入。如果缓存中不存在该 key</span></span><br><span class="line">            <span class="comment">// 则该函数将用于提供默认值，该值在计算后插入缓存中：</span></span><br><span class="line">            System.out.println(cache.get(key1, <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 校验key1对应的value是否插入缓存中</span></span><br><span class="line">            System.out.println(cache.getIfPresent(key1));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 手动put数据填充缓存中</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">            cache.put(key1, value1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用getIfPresent方法从缓存中获取值。如果缓存中不存指定的值，则方法将返回 null：</span></span><br><span class="line">            System.out.println(cache.getIfPresent(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移除数据，让数据失效</span></span><br><span class="line">            cache.invalidate(<span class="number">1</span>);</span><br><span class="line">            System.out.println(cache.getIfPresent(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>同步加载数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> duan.test.caffeine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.CacheLoader;</span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Caffeine;</span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.LoadingCache;</span><br><span class="line"><span class="keyword">import</span> org.checkerframework.checker.nullness.qual.NonNull;</span><br><span class="line"><span class="keyword">import</span> org.checkerframework.checker.nullness.qual.Nullable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaffeineTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 模拟从数据库中读取key</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getInDB</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> key + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 初始化缓存，设置了1分钟的写过期，100的缓存最大个数</span></span><br><span class="line">            LoadingCache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                    .expireAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">                    .maximumSize(<span class="number">100</span>)</span><br><span class="line">                    .build(<span class="keyword">new</span> <span class="title class_">CacheLoader</span>&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Nullable</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> Integer <span class="title function_">load</span><span class="params">(<span class="meta">@NonNull</span> Integer key)</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> getInDB(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">key1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// get数据，取不到则从数据库中读取相关数据，该值也会插入缓存中：</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value1</span> <span class="operator">=</span> cache.get(key1);</span><br><span class="line">            System.out.println(value1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 支持直接get一组值，支持批量查找</span></span><br><span class="line">            Map&lt;Integer, Integer&gt; dataMap</span><br><span class="line">                    = cache.getAll(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">            System.out.println(dataMap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        LoadingCache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .expireAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">                .maximumSize(<span class="number">100</span>)</span><br><span class="line">                .build(<span class="keyword">new</span> <span class="title class_">CacheLoader</span>&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Nullable</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Integer <span class="title function_">load</span><span class="params">(<span class="meta">@NonNull</span> Integer key)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> getInDB(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">key1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// get数据，取不到则从数据库中读取相关数据，该值也会插入缓存中：</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value1</span> <span class="operator">=</span> cache.get(key1);</span><br><span class="line">        System.out.println(value1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 支持直接get一组值，支持批量查找</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; dataMap</span><br><span class="line">                = cache.getAll(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(dataMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>**异步加载 **</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> duan.test.caffeine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.AsyncCache;</span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Caffeine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaffeineTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟从数据库中读取key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getInDB</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 使用executor设置线程池</span></span><br><span class="line">        AsyncCache&lt;Integer, Integer&gt; asyncCache = Caffeine.newBuilder()</span><br><span class="line">                .expireAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">                .maximumSize(<span class="number">100</span>).executor(Executors.newSingleThreadExecutor()).buildAsync();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// get返回的是CompletableFuture</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = asyncCache.get(key, <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(Integer key)</span> &#123;</span><br><span class="line">                <span class="comment">// 执行所在的线程不在是main，而是ForkJoinPool线程池提供的线程</span></span><br><span class="line">                System.out.println(<span class="string">&quot;当前所在线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> getInDB(key);</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> future.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;当前所在线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="淘汰机制"><a href="#淘汰机制" class="headerlink" title="淘汰机制"></a>淘汰机制</h4><p><strong>基于权重</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化缓存，设置最大权重为2</span></span><br><span class="line">        Cache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .maximumWeight(<span class="number">2</span>)</span><br><span class="line">                .weigher(<span class="keyword">new</span> <span class="title class_">Weigher</span>&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="meta">@NonNegative</span> <span class="type">int</span> <span class="title function_">weigh</span><span class="params">(<span class="meta">@NonNull</span> Integer key, <span class="meta">@NonNull</span> Integer value)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> key;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 打印缓存个数，结果为1</span></span><br><span class="line">        System.out.println(cache.estimatedSize());</span><br><span class="line"></span><br><span class="line">        cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 稍微休眠一秒</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 打印缓存个数，结果为1</span></span><br><span class="line">        System.out.println(cache.estimatedSize());</span><br></pre></td></tr></table></figure><p><strong>基于大小</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化缓存，缓存最大个数为1</span></span><br><span class="line">       Cache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">               .maximumSize(<span class="number">1</span>)</span><br><span class="line">               .build();</span><br><span class="line"></span><br><span class="line">       cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">       <span class="comment">// 打印缓存个数，结果为1</span></span><br><span class="line">       System.out.println(cache.estimatedSize());</span><br><span class="line"></span><br><span class="line">       cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">       <span class="comment">// 稍微休眠一秒</span></span><br><span class="line">       Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">       <span class="comment">// 打印缓存个数，结果为1</span></span><br><span class="line">       System.out.println(cache.estimatedSize());</span><br></pre></td></tr></table></figure><p><strong>基于时间</strong></p><p>然后是基于时间的方式，基于时间的回收机制，Caffeine有提供了三种类型，可以分为：</p><ul><li>访问后到期，时间节点从最近一次读或者写，也就是get或者put开始算起。</li><li>写入后到期，时间节点从写开始算起，也就是put。</li><li>自定义策略，自定义具体到期时间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 设置写入5秒后数据到期</span></span><br><span class="line">Cache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .expireAfterWrite(<span class="number">5</span>, TimeUnit.SECONDS).scheduler(Scheduler.systemScheduler())</span><br><span class="line">                .build();</span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(cache.getIfPresent(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(cache.getIfPresent(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置访问5秒后数据到期</span></span><br><span class="line">        Cache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .expireAfterAccess(<span class="number">5</span>, TimeUnit.SECONDS).scheduler(Scheduler.systemScheduler())</span><br><span class="line">                .build();</span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(cache.getIfPresent(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(cache.getIfPresent(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .expireAfter(<span class="keyword">new</span> <span class="title class_">Expiry</span>&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">                    <span class="comment">// 创建1秒后过期，可以看到这里必须要用纳秒</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">expireAfterCreate</span><span class="params">(<span class="meta">@NonNull</span> Integer key, <span class="meta">@NonNull</span> Integer value, <span class="type">long</span> currentTime)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> TimeUnit.SECONDS.toNanos(<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 更新2秒后过期，可以看到这里必须要用纳秒</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">expireAfterUpdate</span><span class="params">(<span class="meta">@NonNull</span> Integer key, <span class="meta">@NonNull</span> Integer value, <span class="type">long</span> currentTime, <span class="meta">@NonNegative</span> <span class="type">long</span> currentDuration)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> TimeUnit.SECONDS.toNanos(<span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 读3秒后过期，可以看到这里必须要用纳秒</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">expireAfterRead</span><span class="params">(<span class="meta">@NonNull</span> Integer key, <span class="meta">@NonNull</span> Integer value, <span class="type">long</span> currentTime, <span class="meta">@NonNegative</span> <span class="type">long</span> currentDuration)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> TimeUnit.SECONDS.toNanos(<span class="number">3</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).scheduler(Scheduler.systemScheduler())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(cache.getIfPresent(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(cache.getIfPresent(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>写后重新计时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置写入后3秒后数据过期，2秒后如果有数据访问则刷新数据</span></span><br><span class="line">        LoadingCache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .refreshAfterWrite(<span class="number">2</span>, TimeUnit.SECONDS) <span class="comment">//刷新机制</span></span><br><span class="line">                .expireAfterWrite(<span class="number">3</span>, TimeUnit.SECONDS)</span><br><span class="line">                .build(<span class="keyword">new</span> <span class="title class_">CacheLoader</span>&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Nullable</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Integer <span class="title function_">load</span><span class="params">(<span class="meta">@NonNull</span> Integer key)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> getInDB();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        cache.put(<span class="number">1</span>, getInDB());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 休眠2.5秒，后取值</span></span><br><span class="line">        Thread.sleep(<span class="number">2500</span>);</span><br><span class="line">        System.out.println(cache.getIfPresent(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 休眠1.5秒，后取值</span></span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        System.out.println(cache.getIfPresent(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h5 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h5><p>说直接给Caffeine设置了最大缓存个数，会存在一个隐患，那便是当同时在线的玩家数超过最大缓存个数的情况下，会导致缓存被清，之后导致频繁读取数据库加载数据，让我在Caffeine的基础上，结合二级缓存解决这个问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 充当二级缓存用，生命周期仅活到下个gc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, WeakReference&lt;Integer&gt;&gt; secondCacheMap =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 设置最大缓存个数为1</span></span><br><span class="line">        LoadingCache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .maximumSize(<span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 设置put和remove的回调</span></span><br><span class="line">                .writer(<span class="keyword">new</span> <span class="title class_">CacheWriter</span>&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="meta">@NonNull</span> Integer key, <span class="meta">@NonNull</span> Integer value)</span> &#123;</span><br><span class="line">                        secondCacheMap.put(key, <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(value));</span><br><span class="line">                        System.out.println(<span class="string">&quot;触发CacheWriter.write，将key = &quot;</span> + key + <span class="string">&quot;放入二级缓存中&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@NonNull</span> Integer key, <span class="meta">@Nullable</span> Integer value, <span class="meta">@NonNull</span> RemovalCause cause)</span> &#123;</span><br><span class="line">                        <span class="keyword">switch</span> (cause) &#123;</span><br><span class="line">                            <span class="keyword">case</span> EXPLICIT:</span><br><span class="line">                                secondCacheMap.remove(key);</span><br><span class="line">                                System.out.println(<span class="string">&quot;触发CacheWriter&quot;</span> +</span><br><span class="line">                                        <span class="string">&quot;.delete，清除原因：主动清除，将key = &quot;</span> + key +</span><br><span class="line">                                        <span class="string">&quot;从二级缓存清除&quot;</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> SIZE:</span><br><span class="line">                                System.out.println(<span class="string">&quot;触发CacheWriter&quot;</span> +</span><br><span class="line">                                        <span class="string">&quot;.delete，清除原因：缓存个数超过上限，key = &quot;</span> + key);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .build(<span class="keyword">new</span> <span class="title class_">CacheLoader</span>&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Nullable</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Integer <span class="title function_">load</span><span class="params">(<span class="meta">@NonNull</span> Integer key)</span> &#123;</span><br><span class="line">                        WeakReference&lt;Integer&gt; value = secondCacheMap.get(key);</span><br><span class="line">                        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;触发CacheLoader.load，从二级缓存读取key = &quot;</span> + key);</span><br><span class="line">                        <span class="keyword">return</span> value.get();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 由于清除缓存是异步的，因而睡眠1秒等待清除完成</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存超上限触发清除后</span></span><br><span class="line">        System.out.println(<span class="string">&quot;从Caffeine中get数据，key为1，value为&quot;</span>+cache.get(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h4 id="淘汰监听"><a href="#淘汰监听" class="headerlink" title="淘汰监听"></a>淘汰监听</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xifanxiaxue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/19 22:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 淘汰通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaffeineRemovalListenerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        LoadingCache&lt;Integer, Integer&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .expireAfterAccess(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">                .scheduler(Scheduler.systemScheduler())</span><br><span class="line">             <span class="comment">// 增加了淘汰监听</span></span><br><span class="line">                .removalListener(((key, value, cause) -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;淘汰通知，key：&quot;</span> + key + <span class="string">&quot;，原因：&quot;</span> + cause);</span><br><span class="line">                &#125;))</span><br><span class="line">                .build(<span class="keyword">new</span> <span class="title class_">CacheLoader</span>&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="meta">@Nullable</span> Integer <span class="title function_">load</span><span class="params">(<span class="meta">@NonNull</span> Integer key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="keyword">return</span> key;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h4><p>利用mq，来更新缓存，需要根据数据库数据判断缓存是否需要更新</p><p><img src="/../img/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A71.jpg"></p><p>利用cancel监控binlog日志更新缓存</p><p><img src="/../img/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A72.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;caffeine-本地缓存&quot;&gt;&lt;a href=&quot;#caffeine-本地缓存&quot; class=&quot;headerlink&quot; title=&quot;caffeine 本地缓存&quot;&gt;&lt;/a&gt;caffeine 本地缓存&lt;/h1&gt;&lt;figure class=&quot;highlight java</summary>
      
    
    
    
    <category term="java" scheme="http://duanyushuai.github.io/categories/java/"/>
    
    
    <category term="缓存" scheme="http://duanyushuai.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>springMVC 源码分析</title>
    <link href="http://duanyushuai.github.io/2023/01/06/springmvc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://duanyushuai.github.io/2023/01/06/springmvc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2023-01-06T02:02:49.137Z</published>
    <updated>2023-01-06T02:13:58.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="springMVC-源码分析"><a href="#springMVC-源码分析" class="headerlink" title="springMVC 源码分析"></a>springMVC 源码分析</h1><p><img src="/../img/SpringMVC%E5%8E%9F%E7%90%86.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;springMVC-源码分析&quot;&gt;&lt;a href=&quot;#springMVC-源码分析&quot; class=&quot;headerlink&quot; title=&quot;springMVC 源码分析&quot;&gt;&lt;/a&gt;springMVC 源码分析&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/../img/Spri</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>自控力</title>
    <link href="http://duanyushuai.github.io/2023/01/05/%E8%87%AA%E6%8E%A7%E5%8A%9B/"/>
    <id>http://duanyushuai.github.io/2023/01/05/%E8%87%AA%E6%8E%A7%E5%8A%9B/</id>
    <published>2023-01-05T02:00:00.000Z</published>
    <updated>2023-03-24T08:49:41.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自控力"><a href="#自控力" class="headerlink" title="自控力"></a>自控力</h1><h4 id="1-冥想"><a href="#1-冥想" class="headerlink" title="1. 冥想"></a>1. 冥想</h4><p>遇到难题有两个想法，专注自己的呼吸5分钟，帮助自己获得更好的选择</p><h4 id="2-关注自己的意志力强弱"><a href="#2-关注自己的意志力强弱" class="headerlink" title="2.  关注自己的意志力强弱"></a>2.  关注自己的意志力强弱</h4><h4 id="3-意志力榜样"><a href="#3-意志力榜样" class="headerlink" title="3. 意志力榜样"></a>3. 意志力榜样</h4><h4 id="4-等待十分钟的诱惑"><a href="#4-等待十分钟的诱惑" class="headerlink" title="4. 等待十分钟的诱惑"></a>4. 等待十分钟的诱惑</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自控力&quot;&gt;&lt;a href=&quot;#自控力&quot; class=&quot;headerlink&quot; title=&quot;自控力&quot;&gt;&lt;/a&gt;自控力&lt;/h1&gt;&lt;h4 id=&quot;1-冥想&quot;&gt;&lt;a href=&quot;#1-冥想&quot; class=&quot;headerlink&quot; title=&quot;1. 冥想&quot;&gt;&lt;/a&gt;1.</summary>
      
    
    
    
    <category term="读书" scheme="http://duanyushuai.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书" scheme="http://duanyushuai.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
</feed>
