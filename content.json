{"meta":{"title":"Duan","subtitle":"有点小菜","description":"有点小菜","author":"小段","url":"http://duanyushuai.github.io","root":"/"},"pages":[{"title":"友情链接","date":"2022-06-12T06:28:38.126Z","updated":"2022-06-12T03:50:30.584Z","comments":true,"path":"links/index.html","permalink":"http://duanyushuai.github.io/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-11-03T09:16:25.884Z","updated":"2022-11-03T09:16:25.884Z","comments":false,"path":"about/index.html","permalink":"http://duanyushuai.github.io/about/index.html","excerpt":"","text":"个人详细介绍 河北 石家庄 毕业 浙江理工大学 本硕 在有限的时间里，做些有意义的事情 Reading for the rise of the ShiJiaZhuang"},{"title":"分类","date":"2022-06-13T02:45:28.915Z","updated":"2022-06-13T02:45:28.915Z","comments":false,"path":"categories/index.html","permalink":"http://duanyushuai.github.io/categories/index.html","excerpt":"","text":"title: CompletableFuturelayout: javacomments :false"},{"title":"书单","date":"2022-06-12T06:25:36.580Z","updated":"2022-06-12T03:50:30.584Z","comments":false,"path":"books/index.html","permalink":"http://duanyushuai.github.io/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-06-12T06:28:38.138Z","updated":"2022-06-12T03:50:30.584Z","comments":false,"path":"repository/index.html","permalink":"http://duanyushuai.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-06-13T03:01:27.694Z","updated":"2022-06-12T06:24:49.702Z","comments":false,"path":"tags/index.html","permalink":"http://duanyushuai.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"excel导入","slug":"excel导入","date":"2022-11-18T03:00:23.000Z","updated":"2022-10-18T14:07:28.242Z","comments":true,"path":"2022/11/18/excel导入/","link":"","permalink":"http://duanyushuai.github.io/2022/11/18/excel%E5%AF%BC%E5%85%A5/","excerpt":"","text":"excel导入百万数据导入1、 我遇到的数据量超级大，使用传统的POI方式来完成导入导出很明显会内存溢出，并且效率会非常低； 2、 数据量大直接使用select * from tableName肯定不行，一下子查出来300w条数据肯定会很慢； 3、 300w 数据导出到Excel时肯定不能都写在一个Sheet中，这样效率会非常低；估计打开都得几分钟； 4、 300w数据导出到Excel中肯定不能一行一行的导出到Excel中。频繁IO操作绝对不行； 5、 导入时300万数据存储到DB如果循环一条条插入也肯定不行； 6、导入时300w数据如果使用Mybatis的批量插入肯定不行，因为Mybatis的批量插入其实就是SQL的循环；一样很慢。 针对1：其实问题所在就是内存溢出，我们只要使用对上面介绍的POI方式即可，主要问题就是原生的POI解决起来相当麻烦。 经过查阅资料翻看到阿里的一款POI封装工具EasyExcel，上面问题等到解决； 针对2：不能一次性查询出全部数据，我们可以分批进行查询，只不过时多查询几次的问题，况且市面上分页插件很多。此问题好解决。 针对3：可以将300w条数据写到不同的Sheet中，每一个Sheet写一百万即可。 针对4：不能一行一行的写入到Excel上，我们可以将分批查询的数据分批写入到Excel中。 针对5：导入到DB时我们可以将Excel中读取的数据存储到集合中，到了一定数量，直接批量插入到DB中。 针对6：不能使用Mybatis的批量插入，我们可以使用JDBC的批量插入，配合事务来完成批量插入到DB。即 Excel读取分批+JDBC分批插入+事务。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public void dataExport300w(HttpServletResponse response) &#123; &#123; OutputStream outputStream = null; try &#123; long startTime = System.currentTimeMillis(); System.out.println(&quot;导出开始时间:&quot; + startTime); outputStream = response.getOutputStream(); ExcelWriter writer = new ExcelWriter(outputStream, ExcelTypeEnum.XLSX); String fileName = new String((&quot;excel100w&quot;).getBytes(), &quot;UTF-8&quot;); //title Table table = new Table(1); List&lt;List&lt;String&gt;&gt; titles = new ArrayList&lt;List&lt;String&gt;&gt;(); titles.add(Arrays.asList(&quot;onlineseqid&quot;)); titles.add(Arrays.asList(&quot;businessid&quot;)); titles.add(Arrays.asList(&quot;becifno&quot;)); titles.add(Arrays.asList(&quot;ivisresult&quot;)); titles.add(Arrays.asList(&quot;createdby&quot;)); titles.add(Arrays.asList(&quot;createddate&quot;)); titles.add(Arrays.asList(&quot;updateby&quot;)); titles.add(Arrays.asList(&quot;updateddate&quot;)); titles.add(Arrays.asList(&quot;risklevel&quot;)); table.setHead(titles); //模拟统计查询的数据数量这里模拟100w int count = 3000001; //记录总数:实际中需要根据查询条件进行统计即可 Integer totalCount = actResultLogMapper.findActResultLogByCondations(count); //每一个Sheet存放100w条数据 Integer sheetDataRows = ExcelConstants.PER_SHEET_ROW_COUNT; //每次写入的数据量20w Integer writeDataRows = ExcelConstants.PER_WRITE_ROW_COUNT; //计算需要的Sheet数量 Integer sheetNum = totalCount % sheetDataRows == 0 ? (totalCount / sheetDataRows) : (totalCount / sheetDataRows + 1); //计算一般情况下每一个Sheet需要写入的次数(一般情况不包含最后一个sheet,因为最后一个sheet不确定会写入多少条数据) Integer oneSheetWriteCount = sheetDataRows / writeDataRows; //计算最后一个sheet需要写入的次数 Integer lastSheetWriteCount = totalCount % sheetDataRows == 0 ? oneSheetWriteCount : (totalCount % sheetDataRows % writeDataRows == 0 ? (totalCount / sheetDataRows / writeDataRows) : (totalCount / sheetDataRows / writeDataRows + 1)); //开始分批查询分次写入 //注意这次的循环就需要进行嵌套循环了,外层循环是Sheet数目,内层循环是写入次数 List&lt;List&lt;String&gt;&gt; dataList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; sheetNum; i++) &#123; //创建Sheet Sheet sheet = new Sheet(i, 0); sheet.setSheetName(&quot;测试Sheet1&quot; + i); //循环写入次数: j的自增条件是当不是最后一个Sheet的时候写入次数为正常的每个Sheet写入的次数,如果是最后一个就需要使用计算的次数lastSheetWriteCount for (int j = 0; j &lt; (i != sheetNum - 1 ? oneSheetWriteCount : lastSheetWriteCount); j++) &#123; //集合复用,便于GC清理 dataList.clear(); //分页查询一次20w PageHelper.startPage(j + 1 + oneSheetWriteCount * i, writeDataRows); List&lt;ActResultLog&gt; reslultList = actResultLogMapper.findByPage100w(); if (!CollectionUtils.isEmpty(reslultList)) &#123; reslultList.forEach(item -&gt; &#123; dataList.add(Arrays.asList(item.getOnlineseqid(), item.getBusinessid(), item.getBecifno(), item.getIvisresult(), item.getCreatedby(), Calendar.getInstance().getTime().toString(), item.getUpdateby(), Calendar.getInstance().getTime().toString(), item.getRisklevel())); &#125;); &#125; //写数据 writer.write0(dataList, sheet, table); &#125; &#125; // 下载EXCEL response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + new String((fileName).getBytes(&quot;gb2312&quot;), &quot;ISO-8859-1&quot;) + &quot;.xlsx&quot;); response.setContentType(&quot;multipart/form-data&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); writer.finish(); outputStream.flush(); //导出时间结束 long endTime = System.currentTimeMillis(); System.out.println(&quot;导出结束时间:&quot; + endTime + &quot;ms&quot;); System.out.println(&quot;导出所用时间:&quot; + (endTime - startTime) / 1000 + &quot;秒&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (outputStream != null) &#123; try &#123; outputStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 300W数据的导入解决思路1、首先是分批读取读取Excel中的300w数据，这一点EasyExcel有自己的解决方案，我们可以参考Demo即可，只需要把它分批的参数3000调大即可。我是用的20w；（一会儿代码一看就能明白） 2、其次就是往DB里插入，怎么去插入这20w条数据，当然不能一条一条的循环，应该批量插入这20w条数据，同样也不能使用Mybatis的批量插入语，因为效率也低。可以参考下面链接【Myabtis批量插入和JDBC批量插入性能对比】 3、使用JDBC+事务的批量操作将数据插入到数据库。（分批读取+JDBC分批插入+手动事务控制） 123456789101112// EasyExcel的读取Excel数据的API@Testpublic void import2DBFromExcel10wTest() &#123; String fileName = &quot;D:\\\\StudyWorkspace\\\\JavaWorkspace\\\\java_project_workspace\\\\idea_projects\\\\SpringBootProjects\\\\easyexcel\\\\exportFile\\\\excel300w.xlsx&quot;; //记录开始读取Excel时间,也是导入程序开始时间 long startReadTime = System.currentTimeMillis(); System.out.println(&quot;------开始读取Excel的Sheet时间(包括导入数据过程):&quot; + startReadTime + &quot;ms------&quot;); //读取所有Sheet的数据.每次读完一个Sheet就会调用这个方法 EasyExcel.read(fileName, new EasyExceGeneralDatalListener(actResultLogService2)).doReadAll(); long endReadTime = System.currentTimeMillis(); System.out.println(&quot;------结束读取Excel的Sheet时间(包括导入数据过程):&quot; + endReadTime + &quot;ms------&quot;);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 事件监听public class EasyExceGeneralDatalListener extends AnalysisEventListener&lt;Map&lt;Integer, String&gt;&gt; &#123; /** * 处理业务逻辑的Service,也可以是Mapper */ private ActResultLogService2 actResultLogService2; /** * 用于存储读取的数据 */ private List&lt;Map&lt;Integer, String&gt;&gt; dataList = new ArrayList&lt;Map&lt;Integer, String&gt;&gt;(); public EasyExceGeneralDatalListener() &#123; &#125; public EasyExceGeneralDatalListener(ActResultLogService2 actResultLogService2) &#123; this.actResultLogService2 = actResultLogService2; &#125; @Override public void invoke(Map&lt;Integer, String&gt; data, AnalysisContext context) &#123; //数据add进入集合 dataList.add(data); //size是否为100000条:这里其实就是分批.当数据等于10w的时候执行一次插入 if (dataList.size() &gt;= ExcelConstants.GENERAL_ONCE_SAVE_TO_DB_ROWS) &#123; //存入数据库:数据小于1w条使用Mybatis的批量插入即可; saveData(); //清理集合便于GC回收 dataList.clear(); &#125; &#125; /** * 保存数据到DB * * @param * @MethodName: saveData * @return: void */ private void saveData() &#123; actResultLogService2.import2DBFromExcel10w(dataList); dataList.clear(); &#125; /** * Excel中所有数据解析完毕会调用此方法 * * @param: context * @MethodName: doAfterAllAnalysed * @return: void */ @Override public void doAfterAllAnalysed(AnalysisContext context) &#123; saveData(); dataList.clear(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//JDBC工具类public class JDBCDruidUtils &#123; private static DataSource dataSource; /* 创建数据Properties集合对象加载加载配置文件 */ static &#123; Properties pro = new Properties(); //加载数据库连接池对象 try &#123; //获取数据库连接池对象 pro.load(JDBCDruidUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;)); dataSource = DruidDataSourceFactory.createDataSource(pro); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /* 获取连接 */ public static Connection getConnection() throws SQLException &#123; return dataSource.getConnection(); &#125; /** * 关闭conn,和 statement独对象资源 * * @param connection * @param statement * @MethodName: close * @return: void */ public static void close(Connection connection, Statement statement) &#123; if (connection != null) &#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (statement != null) &#123; try &#123; statement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 关闭 conn , statement 和resultset三个对象资源 * * @param connection * @param statement * @param resultSet * @MethodName: close * @return: void */ public static void close(Connection connection, Statement statement, ResultSet resultSet) &#123; close(connection, statement); if (resultSet != null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /* 获取连接池对象 */ public static DataSource getDataSource() &#123; return dataSource; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// Service中具体业务逻辑/** * 测试用Excel导入超过10w条数据,经过测试发现,使用Mybatis的批量插入速度非常慢,所以这里可以使用 数据分批+JDBC分批插入+事务来继续插入速度会非常快 * * @param * @MethodName: import2DBFromExcel10w * @return: java.util.Map&lt;java.lang.String, java.lang.Object&gt; */@Overridepublic Map&lt;String, Object&gt; import2DBFromExcel10w(List&lt;Map&lt;Integer, String&gt;&gt; dataList) &#123; HashMap&lt;String, Object&gt; result = new HashMap&lt;&gt;(); //结果集中数据为0时,结束方法.进行下一次调用 if (dataList.size() == 0) &#123; result.put(&quot;empty&quot;, &quot;0000&quot;); return result; &#125; //JDBC分批插入+事务操作完成对10w数据的插入 Connection conn = null; PreparedStatement ps = null; try &#123; long startTime = System.currentTimeMillis(); System.out.println(dataList.size() + &quot;条,开始导入到数据库时间:&quot; + startTime + &quot;ms&quot;); conn = JDBCDruidUtils.getConnection(); //控制事务:默认不提交 conn.setAutoCommit(false); String sql = &quot;insert into ACT_RESULT_LOG (onlineseqid,businessid,becifno,ivisresult,createdby,createddate,updateby,updateddate,risklevel) values&quot;; sql += &quot;(?,?,?,?,?,?,?,?,?)&quot;; ps = conn.prepareStatement(sql); //循环结果集:这里循环不支持&quot;烂布袋&quot;表达式 for (int i = 0; i &lt; dataList.size(); i++) &#123; Map&lt;Integer, String&gt; item = dataList.get(i); ps.setString(1, item.get(0)); ps.setString(2, item.get(1)); ps.setString(3, item.get(2)); ps.setString(4, item.get(3)); ps.setString(5, item.get(4)); ps.setTimestamp(6, new Timestamp(System.currentTimeMillis())); ps.setString(7, item.get(6)); ps.setTimestamp(8, new Timestamp(System.currentTimeMillis())); ps.setString(9, item.get(8)); //将一组参数添加到此 PreparedStatement 对象的批处理命令中。 ps.addBatch(); &#125; //执行批处理 ps.executeBatch(); //手动提交事务 conn.commit(); long endTime = System.currentTimeMillis(); System.out.println(dataList.size() + &quot;条,结束导入到数据库时间:&quot; + endTime + &quot;ms&quot;); System.out.println(dataList.size() + &quot;条,导入用时:&quot; + (endTime - startTime) + &quot;ms&quot;); result.put(&quot;success&quot;, &quot;1111&quot;); &#125; catch (Exception e) &#123; result.put(&quot;exception&quot;, &quot;0000&quot;); e.printStackTrace(); &#125; finally &#123; //关连接 JDBCDruidUtils.close(conn, ps); &#125; return result;&#125;","categories":[{"name":"springboot","slug":"springboot","permalink":"http://duanyushuai.github.io/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://duanyushuai.github.io/tags/springboot/"}]},{"title":"设计模式","slug":"设计模式","date":"2022-11-08T09:21:31.529Z","updated":"2022-11-11T12:14:52.138Z","comments":true,"path":"2022/11/08/设计模式/","link":"","permalink":"http://duanyushuai.github.io/2022/11/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"[toc] 设计模式1.创建型模式1. 单例模式1234567891011121314public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 2.原型创建重复对象 实现接口Cloneable 12345678910111213141516171819```#### 3.工厂**简单工厂 **```java/** * 工厂的产品 */public abstract class AbstractCar &#123; String engine; public abstract void run();&#125; 123456789101112public class MiniCar extends AbstractCar&#123; public MiniCar()&#123; this.engine = &quot;四缸水平对置发动机&quot;; &#125; @Override public void run() &#123; System.out.println(engine+&quot;--&gt; 嘟嘟嘟...&quot;); &#125;&#125; 1234567891011121314/** * 具体产品 */public class VanCar extends AbstractCar&#123; public VanCar()&#123; this.engine = &quot;单杠柴油机&quot;; &#125; @Override public void run() &#123; System.out.println(engine+&quot;--》嗒嗒嗒....&quot;); &#125;&#125; 123456789101112131415161718192021222324252627 * 简单工厂 * 1、产品数量极少 */public class WuLinSimpleFactory &#123; /** * * @param type Class: 好像具有扩展性，但是没有解决实际问题 * @return */ public AbstractCar newCar(String type)&#123; //核心方法：一切从简 if(&quot;van&quot;.equals(type))&#123; // 钣金、喷漆、放发动机、申请环保 return new VanCar(); &#125;else if(&quot;mini&quot;.equals(type))&#123; return new MiniCar(); &#125; //..... //更多的产品，违反开闭原则。应该直接扩展出一个类来造 return null; &#125;&#125; 4.建造者12//builder lombok 2.结构模式1.适配器模式已有两个接口，在不改变两个接口的情况下，完成两个接口的合并 1234567891011121314151617181920212223/** * 继承的方式：类结构模型，适配转换到了翻译器的功能上 * * */public class JPMoviePlayerAdapter extends Zh_JPTranslator implements Player &#123; private Player target;//被适配对象 public JPMoviePlayerAdapter(Player target)&#123; this.target = target; &#125; @Override public String play() &#123; String play = target.play(); //转换字幕 String translate = translate(play); System.out.println(&quot;日文：&quot;+translate); return play; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435package com.atguigu.design.structural.adapter.obj;import com.atguigu.design.structural.adapter.Player;import com.atguigu.design.structural.adapter.Translator;import com.atguigu.design.structural.adapter.Zh_JPTranslator;/** * 组合的方式：对象结构模型，适配转换到了翻译器的功能上 * * （继承、组合）、封装、多态 * * * */public class JPMoviePlayerAdapter implements Player &#123; //组合的方式 private Translator translator = new Zh_JPTranslator(); private Player target;//被适配对象 public JPMoviePlayerAdapter(Player target)&#123; this.target = target; &#125; @Override public String play() &#123; String play = target.play(); //转换字幕 String translate = translator.translate(play); System.out.println(&quot;日文：&quot;+translate); return play; &#125;&#125; 2. 桥接模式真正引起一个类变换的维度直接抽取出来，通过组合的方式侨接起来 12345678910111213141516171819202122/** * 1、抽象手机类 * 手机有各种销售渠道价格都不一样 * */public abstract class AbstractPhone &#123; //桥接在此.....设计期间就得想好 //桥接+适配器 ... AbstractSale sale; //分离渠道【桥接的关注点】// abstract int getPrice(); 如果这么写需要多少个实现。违反开闭原则 /** * 当前手机的描述 * @return */ abstract String getPhone(); public void setSale(AbstractSale sale) &#123; this.sale = sale; &#125; 123456789101112131415161718192021222324252627/** * 抽象销售渠道 * PhoneOnSale ==howToSale * PhoneOffSale == howToSale * PhoneStudentSale = howToSale * PhonePDD == howToSale * * */public abstract class AbstractSale &#123; private String type; private Integer price; public AbstractSale(String type,Integer price)&#123; this.type = type; this.price = price; &#125; String getSaleInfo()&#123; return &quot;渠道：&quot;+type+&quot;==&gt;&quot;+&quot;价格：&quot;+price; &#125; void howToSale()&#123; //都不一样 &#125;&#125; 3. 装饰器模式增强一个类 12//wrapper Pattern//已有的类功能不够用时，增强方法，当引用第三方就是适配器了 4.代理动态代理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class JdkTiktokProxy&lt;T&gt; implements InvocationHandler &#123; private T target; //接受被代理对象 JdkTiktokProxy(T target)&#123; this.target = target; &#125; /** * 获取被代理对象的 代理对象 * @param t * @param &lt;T&gt; * @return */ public static&lt;T&gt; T getProxy(T t) &#123; /** * ClassLoader loader, 当前被代理对象的类加载器 * Class&lt;?&gt;[] interfaces, 当前被代理对象所实现的所有接口 * InvocationHandler h, * 当前被代理对象执行目标方法的时候我们使用h可以定义拦截增强方法 */ Object o = Proxy.newProxyInstance( t.getClass().getClassLoader(), t.getClass().getInterfaces(), //必须接口 new JdkTiktokProxy(t)); return (T)o; &#125; /** * 定义目标方法的拦截逻辑；每个方法都会进来的 * * @param proxy * @param method * @param args * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //反射执行 System.out.println(&quot;真正执行被代理对象的方法&quot;); Object invoke = method.invoke(target, args); System.out.println(&quot;返回值：一堆美女&quot;); return invoke; &#125;&#125; 1234567891011121314151617181920212223242526/** * 动态代理模式： * JDK要求被代理对象必须有接口 * * 代理对象和目标对象的相同点在于都是同一个接口 */public class MainTest &#123; public static void main(String[] args) &#123; ManTikTok leiTikTok = new LeiTikTok(); /** * 动态代理机制。 */ ManTikTok proxy = JdkTiktokProxy.getProxy(leiTikTok); proxy.tiktok(); ((SellTikTok)proxy).sell(); //能不能代理被代理对象本类自己的方法?proxy只能转成接口类// ((LeiTikTok)proxy).haha(); System.out.println(Arrays.asList(proxy.getClass().getInterfaces())); &#125;&#125; cglib 12345678910111213141516171819202122232425262728293031323334353637/** * 1、使用cglib帮我们创建出代理对象 */public class CglibProxy &#123; //为任意对象创建代理 public static&lt;T&gt; T createProxy(T t)&#123; //1、创建一个增强器 Enhancer enhancer = new Enhancer(); //2、设置要增强哪个个类的功能。增强器为这个类动态创建一个子类 enhancer.setSuperclass(t.getClass()); //3、设置回调 enhancer.setCallback(new MethodInterceptor() &#123; @Override public Object intercept(Object obj, Method method, //为了能获取到原方法的一些元数据信息 Object[] args, MethodProxy proxy) throws Throwable &#123; //编写拦截的逻辑 System.out.println(&quot;cglib上场le .......xxx&quot;); //当前方法的信息// method.get// method.getAnnotation() //目标方法进行执行 Object invoke = proxy.invokeSuper(obj,args); return invoke; &#125; &#125;); Object o = enhancer.create(); return (T) o; &#125;&#125; 5.外观模式123456//去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。以此类比......//JAVA 的三层开发模式。//分布式系统的网关//Tomcat源码中的RequestFacade干什么的？//...... 6.组合模式1//树形结构 层级结构 7.享元模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//就是线程池/** * 足道店：这相当于享元工厂 * 店里面很多服务员。 * * 享元和原型 * 1、享元返回的是这个本人。 * 2、原型返回的是克隆人。 * */public class ZuDao &#123; private static Map&lt;String,AbstractWaitressFlyweight&gt; pool = new HashMap&lt;&gt;(); //享元，池子中有对象 static &#123; BeautifulWaitress waitress = new BeautifulWaitress(&quot;1111&quot;,&quot;张三&quot;,18); BeautifulWaitress waitress2 = new BeautifulWaitress(&quot;9527&quot;,&quot;李四&quot;,20); pool.put(waitress.id,waitress); pool.put(waitress2.id,waitress2); &#125; public void addWaitress(AbstractWaitressFlyweight waitressFlyweight)&#123; pool.put(UUID.randomUUID().toString(),waitressFlyweight); &#125; public static AbstractWaitressFlyweight getWaitress(String name)&#123; AbstractWaitressFlyweight flyweight = pool.get(name); if(flyweight == null)&#123; for (AbstractWaitressFlyweight value : pool.values()) &#123; //当前共享对象能否是否 if(value.isCanService())&#123; return value; &#125; &#125;; return null; &#125; return flyweight; &#125;&#125; 123456789101112131415161718192021222324252627/** * 具体享元类 */@AllArgsConstructorpublic class BeautifulWaitress extends AbstractWaitressFlyweight&#123; String id;//工号 String name;//名字 int age;//年龄 //以上是不变的 @Override void service() &#123; System.out.println(&quot;工号：&quot;+id+&quot;；&quot;+name+&quot; &quot;+age+&quot; 正在为您服务...&quot;); //改变外部状态 this.canService = false; &#125; @Override void end() &#123; System.out.println(&quot;工号：&quot;+id+&quot;；&quot;+name+&quot; &quot;+age+&quot; 服务结束...请给五星好评&quot;); this.canService = true; &#125;&#125; 3.行为模式1.模版方法123456789101112131415161718192021222324252627282930313233343536373839404142/** * 1、定义模板 */public abstract class CookTemplate &#123; /** * 定义算法： 定义好了模板 * 父类可以实现某些步骤 * 留关键给子类 */ public void cook()&#123; //定义算法步骤 heating(); //v addfood(); addsalt(); stirfry(); //v end(); //v &#125; //加热方法 public void heating()&#123; System.out.println(&quot;开火...&quot;); &#125;; //添加食物 public abstract void addfood(); //加盐 public abstract void addsalt(); //翻炒 public void stirfry()&#123; System.out.println(&quot;翻炒中...&quot;); &#125;; //出锅 public void end()&#123; System.out.println(&quot;出锅....&quot;); &#125;;&#125; 2.策略模式定义整体方法，可以将一部分抽离出来，装配策略 1234567891011121314151617181920/** * 环境类 */public class TeamGNR &#123; //抽取游戏策略算法，并进行引用 private GameStrategy gameStrategy; public void setGameStrategy(GameStrategy gameStrategy) &#123; this.gameStrategy = gameStrategy; &#125; public void startGame()&#123; System.out.println(&quot;游戏开始.....&quot;); //游戏策略 // gameStrategy.warStrategy(); System.out.println(&quot;win......&quot;); &#125;&#125; 3.状态模式状态机 123456789101112131415161718/** * 竞赛状态 */public class MatchState implements TeamState&#123; @Override public void playGame() &#123; System.out.println(&quot;全力以赴打比赛....&quot;); &#125; //状态模式的核心 @Override public TeamState next() &#123; return new VocationState(); &#125;&#125; 4.中介者模式 5.观察者模式12345678910111213141516171819202122232425262728** * 抽象观察者 */public abstract class AbstractFans &#123; List&lt;AbstractTikToker&gt; tikTokers;//双向观察 abstract void acceptMsg(String msg); void follow(AbstractTikToker tikToker)&#123; //主播增粉了 tikToker.addFans(this);// for (AbstractTikToker toker : tikTokers) &#123;//// &#125; &#125;;&#125;public class HumanFans extends AbstractFans &#123; @Override void acceptMsg(String msg) &#123; System.out.println(&quot;主播说：&quot;+msg); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 抖音主播 * * 粉丝观察主播.... */public abstract class AbstractTikToker &#123; //添加粉丝 abstract void addFans(AbstractFans fans); //通知粉丝 abstract void notifyFans(String msg);&#125;/** * 主播 * 双向观察 */public class MMTikToker extends AbstractTikToker&#123; //1、观察者的核心1 List&lt;AbstractFans&gt; fansList = new ArrayList&lt;&gt;(); void startSell() &#123; System.out.println(&quot;雷丰阳... 开始卖货...源码设计课&quot;); notifyFans(&quot;我开始卖东西了，是源码设计课，只要666&quot;); &#125; void endSell() &#123; System.out.println(&quot;雷丰阳... 结束卖货...源码设计课&quot;); notifyFans(&quot;课已经卖完了，记得五星好评...&quot;); &#125; @Override void addFans(AbstractFans fans) &#123; fansList.add(fans); &#125; @Override void notifyFans(String msg) &#123; //1、所有粉丝拿来通知 for (AbstractFans fans : fansList) &#123; fans.acceptMsg(msg); &#125; &#125;&#125; 6.备忘录模式1234//什么场景用到？//游戏存档//数据库保存点事务（savepoint）//session活化钝化 7.解释器模式 12345678910111213141516171819202122/** * 终结符表达式 * * 多少种解析规则就需要定义多少种规则类 * */public class TerminalExpression extends IDCardExpression &#123; String[] data; String symbol; //定义解析用的符号如 ： - public TerminalExpression(String[] data,String symbol)&#123; this.data = data; this.symbol = symbol; &#125; @Override boolean interpret(String expression) &#123; return false; &#125;&#125; 123456789101112131415161718192021/** * 非终结表达式 */public class OrExpression extends IDCardExpression &#123; //组合两个终结表达式。最终的判断结果是终结表达式判断出来的，这个表达式只是一个桥梁 private IDCardExpression cityExp; private IDCardExpression typeExp; public OrExpression(IDCardExpression cityExp, IDCardExpression typeExp) &#123; this.cityExp = cityExp; this.typeExp = typeExp; &#125; @Override boolean interpret(String expression) &#123; return cityExp.interpret(expression) || typeExp.interpret(expression); &#125;&#125; 9.命令模式mvc就是命令模式 10. 迭代器模式11.访问者模式 将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。 123456789101112public class CPU extends Hardware&#123; public CPU(String command) &#123; super(command); &#125; @Override public void accept(Vistor vistor) &#123; //软件包要能访问当前硬件 vistor.visitCPU(this); &#125;&#125; 1234567891011public class Disk extends Hardware&#123; public Disk(String command) &#123; super(command); &#125; @Override public void accept(Vistor vistor) &#123; vistor.visitDisk(this); &#125;&#125; 123456789101112131415public abstract class Hardware &#123; String command;//封装硬件的处理指令 public Hardware(String command)&#123; this.command = command; &#125; public void work()&#123; System.out.println(command); &#125; //定义接受软件升级包的方法。这个方法应该具体硬件去实现 public abstract void accept(Vistor vistor);&#125; 123456789101112131415/** * 升级包可以更改指令 */public class UpdatePackage implements Vistor&#123; @Override public void visitCPU(CPU cpu) &#123; cpu.command+=&quot;；正在联网查询...&quot;; &#125; @Override public void visitDisk(Disk disk) &#123; disk.command+=&quot;；正在保存记录&quot;; &#125;&#125; 1234567public interface Vistor &#123; void visitCPU(CPU cpu); void visitDisk(Disk disk);&#125;","categories":[],"tags":[]},{"title":"树形结构","slug":"树形接口","date":"2022-11-04T09:20:20.358Z","updated":"2022-11-06T02:45:36.918Z","comments":true,"path":"2022/11/04/树形接口/","link":"","permalink":"http://duanyushuai.github.io/2022/11/04/%E6%A0%91%E5%BD%A2%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"树形结构怎么做**实体类 ** 123456789101112131415161718192021222324252627282930import lombok.Data;import java.util.ArrayList;import java.util.List;/** * @author变成派大星 */@Datapublic class Node &#123; private Integer Id; private String name; private Integer pid; private List&lt;Node&gt; treeNode = new ArrayList&lt;&gt;(); public Node(int id, int pid) &#123; this.Id = id; this.pid = pid; &#125; public Node(int id, int pid, String name) &#123; this(id, pid); this.name = name; &#125;&#125; 方法一12345678910111213141516171819202122232425public List&lt;Node&gt; handleTreeVo() &#123; Node first = new Node(1, 0, &quot;first&quot;); Node second = new Node(2, 1, &quot;second&quot;); Node third = new Node(3, 2, &quot;third&quot;); Node second001 = new Node(4, 1, &quot;second001&quot;); Node third001 = new Node(5, 4, &quot;third001&quot;); // 组装树状数据List&lt;Node&gt; nodes = Arrays.asList(first,second,third,second001,third001); return buildTree(nodes);&#125;public List&lt;Node&gt; buildTree(List&lt;Node&gt; nodes) &#123; //将这些非顶级节点的数据按pid进行分组 这个是根据pid为key 第一步过滤非Pid=0的节点 第二步进行分组 Map&lt;Integer, List&lt;Node&gt;&gt; nodeMap = nodes.stream().filter(node-&gt;node.getPid()!=0) .collect(Collectors.groupingBy(node -&gt; node.getPid())); //循环设置对应的子节点（根据id = pid） 上一步以pid为Key 所以就直接循环获取 nodes.forEach(node -&gt; node.setTreeNode(nodeMap.get(node.getId()))); //过滤第一层不是Pid为零的数据 也就是没有根节点的数据 List&lt;Node&gt; treeNode = nodes.stream().filter(node -&gt; node.getPid() == 0).collect(Collectors.toList()); return treeNode;&#125; 方法二12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import cn.hutool.core.collection.CollUtil;import com.baomidou.mybatisplus.core.toolkit.CollectionUtils;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.function.BiConsumer;import java.util.function.Function;import java.util.function.Predicate;import java.util.stream.Collectors;/** * @author 变成派大星 */public class TreeUtils &#123; /** * @param list 源数据 * @param setChildListFn 设置递归的方法 * @param idFn 获取id的方法 * @param pidFn 获取父id的方法 * @param getRootCondition 获取根节点的提哦啊见 * @return 将List 转换成 Tree */ public static &lt;M, T&gt; List&lt;M&gt; listToTree(List&lt;M&gt; list, Function&lt;M, T&gt; idFn, Function&lt;M, T&gt; pidFn, BiConsumer&lt;M, List&lt;M&gt;&gt; setChildListFn, Predicate&lt;M&gt; getRootCondition) &#123; if (CollUtil.isEmpty(list)) return null; Map&lt;T, List&lt;M&gt;&gt; listMap = list.stream().collect(Collectors.groupingBy(pidFn)); list.forEach(model -&gt; setChildListFn.accept(model, listMap.get(idFn.apply(model)))); return list.stream().filter(getRootCondition).collect(Collectors.toList()); &#125; public static &lt;M&gt; List&lt;M&gt; treeToList(List&lt;M&gt; source, Function&lt;M, List&lt;M&gt;&gt; getChildListFn, BiConsumer&lt;M, List&lt;M&gt;&gt; setChildListFn, Predicate&lt;M&gt; getRootCondition) &#123; List&lt;M&gt; target = new ArrayList&lt;&gt;(); if (CollectionUtils.isNotEmpty(source)) &#123; treeToList(source, target, getChildListFn); target.forEach(model -&gt; setChildListFn.accept(model, null)); target.addAll(target.stream().filter(getRootCondition).collect(Collectors.toList())); &#125; return target; &#125; private static &lt;F&gt; void treeToList(List&lt;F&gt; source, List&lt;F&gt; target, Function&lt;F, List&lt;F&gt;&gt; getChildListFn) &#123; if (CollectionUtils.isNotEmpty(source)) &#123; target.addAll(source); source.forEach(model -&gt; &#123; List&lt;F&gt; childList = getChildListFn.apply(model); if (CollectionUtils.isNotEmpty(childList)) &#123; treeToList(childList, target, getChildListFn); &#125; &#125;); &#125; &#125;&#125; 例子 123456789101112public List&lt;Node&gt; handleTree()&#123; Node first = new Node(1, 0, &quot;first&quot;); Node second = new Node(2, 1, &quot;second&quot;); Node third = new Node(3, 2, &quot;third&quot;); Node second001 = new Node(4, 1, &quot;second001&quot;); Node third001 = new Node(5, 4, &quot;third001&quot;); List&lt;Node&gt; nodes = Arrays.asList(first,second,third,second001,third001); List&lt;Node&gt; nodeList = TreeUtils.listToTree(nodes, Node::getId, Node::getPid, Node::setTreeNode, (l) -&gt; l.getPid() == 0); // 树状结构转换成 List 也就是还原数据 return TreeUtils.treeToList(nodeList, Node::getTreeNode, Node::setTreeNode, (l) -&gt; l.getPid() == 0);&#125;","categories":[],"tags":[]},{"title":"","slug":"Untitled","date":"2022-11-04T09:20:14.191Z","updated":"2022-11-04T09:20:14.191Z","comments":true,"path":"2022/11/04/Untitled/","link":"","permalink":"http://duanyushuai.github.io/2022/11/04/Untitled/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"链表","slug":"算法","date":"2022-10-26T12:26:17.945Z","updated":"2022-11-03T10:53:46.135Z","comments":true,"path":"2022/10/26/算法/","link":"","permalink":"http://duanyushuai.github.io/2022/10/26/%E7%AE%97%E6%B3%95/","excerpt":"","text":"链表1. 反转列表12345678910111213141516171819202122232425262728293031323334353637/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; ListNode rHead = new ListNode(-1); while(head!=null)&#123; ListNode p = head; head = head.next; p.next = rHead.next; rHead.next = p; &#125; return rHead.next; &#125;&#125;public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; ListNode newHead = null; ListNode temp =null; while(head!=null)&#123; temp = head.next; head.next = newHead; newHead = head; head = temp; &#125; return newHead; &#125;&#125; 2. 列表执行区间内反转将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O(n)O(n)，空间复杂度 O(1)O(1)。例如：给出的链表为 1\\to 2 \\to 3 \\to 4 \\to 5 \\to NULL1→2→3→4→5→NUL**L, m&#x3D;2,n&#x3D;4m&#x3D;2,n&#x3D;4,返回 1\\to 4\\to 3\\to 2\\to 5\\to NULL1→4→3→2→5→NUL**L. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.util.*;/* * public class ListNode &#123; * int val; * ListNode next = null; * &#125; */public class Solution &#123; /** * * @param head ListNode类 * @param m int整型 * @param n int整型 * @return ListNode类 */ // 解法一：双指针(两次遍历) //说明：方便理解，以下注释中将用left，right分别代替m,n节点 public ListNode reverseBetween (ListNode head, int m, int n) &#123; //设置虚拟头节点 ListNode dummyNode = new ListNode(-1); dummyNode.next = head; ListNode pre = dummyNode; //1.走left-1步到left的前一个节点 for(int i=0;i&lt;m-1;i++)&#123; pre = pre.next; &#125; //2.走roght-left+1步到right节点 ListNode rigthNode = pre; for(int i=0;i&lt;n-m+1;i++)&#123; rigthNode = rigthNode.next; &#125; //3.截取出一个子链表 ListNode leftNode = pre.next; ListNode cur = rigthNode.next; //4.切断链接 pre.next=null; rigthNode.next=null; //5.反转局部链表 reverseLinkedList(leftNode); //6.接回原来的链表 pre.next = rigthNode; leftNode.next = cur; return dummyNode.next; &#125; //反转局部链表 private void reverseLinkedList(ListNode head)&#123; ListNode pre = null; ListNode cur = head; while(cur!=null)&#123; //Cur_next 指向cur节点的下一个节点 ListNode Cur_next = cur.next; cur.next = pre; pre = cur; cur = Cur_next ; &#125; &#125;&#125; 3. 链表每k组反转将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样你不能更改节点中的值，只能更改节点本身。 1234567891011121314151617181920212223242526272829import java.util.*;public class Solution &#123; public ListNode reverseKGroup (ListNode head, int k) &#123; //找到每次翻转的尾部 ListNode tail = head; //遍历k次到尾部 for(int i = 0; i &lt; k; i++)&#123; //如果不足k到了链表尾，直接返回，不翻转 if(tail == null) return head; tail = tail.next; &#125; //翻转时需要的前序和当前节点 ListNode pre = null; ListNode cur = head; //在到达当前段尾节点前 while(cur != tail)&#123; //翻转 ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; &#125; //当前尾指向下一段要翻转的链表 head.next = reverseKGroup(tail, k); return pre; &#125;&#125; 4. 合并两个排序的链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode Merge(ListNode list1, ListNode list2) &#123; ListNode temp = new ListNode(-1); ListNode head = temp; while (list1 != null &amp;&amp; list2 != null) &#123; if (list1.val &lt;= list2.val) &#123; temp.next = list1; temp = temp.next; list1 = list1.next; &#125; else &#123; temp.next = list2; temp = temp.next; list2 = list2.next; &#125; &#125; if (list1 == null) &#123; temp.next = list2; &#125; if (list2 == null) &#123; temp.next = list1; &#125; return head.next; &#125;&#125;//递归public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; // list1 list2为空的情况 if(list1 == null || list2 == null)&#123; return list1 != null ? list1 : list2; &#125; // 两个链表元素依次对比 if(list1.val &lt;= list2.val)&#123; // 递归计算 list1.next, list2 list1.next = Merge(list1.next, list2); return list1; &#125;else&#123; // 递归计算 list1, list2.next list2.next = Merge(list1, list2.next); return list2; &#125; &#125;&#125; 5. 合并k个已排序的列表123456789101112131415161718192021222324252627282930import java.util.*;public class Solution &#123; public ListNode mergeKLists(ArrayList&lt;ListNode&gt; lists) &#123; //小顶堆 Queue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;((v1, v2) -&gt; v1.val - v2.val); //遍历所有链表第一个元素 for (int i = 0; i &lt; lists.size(); i++) &#123; //不为空则加入小顶堆 if (lists.get(i) != null) pq.offer(lists.get(i)); &#125; //加一个表头 ListNode res = new ListNode(-1); ListNode head = res; //直到小顶堆为空 while (!pq.isEmpty()) &#123; //取出最小的元素 ListNode temp = pq.poll(); //连接 head.next = temp; head = head.next; //每次取出链表的后一个元素加入小顶堆 if (temp.next != null) pq.add(temp.next); &#125; //去掉表头 return res.next; &#125;&#125; 6. 链表中的环的入口节点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode EntryNodeOfLoop(ListNode pHead) &#123; if (pHead == null) return null; ListNode slow = pHead; ListNode fast = pHead; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (slow == fast) break; &#125; if (fast == null || fast.next == null) return null; fast = pHead; while (fast != slow) &#123; fast = fast.next; slow = slow.next; &#125; return fast; &#125;&#125;// 哈希表 public ListNode EntryNodeOfLoop(ListNode pHead) &#123; // 使用set来记录出现的结点 HashSet&lt;ListNode&gt; set = new HashSet&lt;&gt;(); while(pHead != null)&#123; // 当set中包含结点，说明第一次出现重复的结点，即环的入口结点 if(set.contains(pHead))&#123; return pHead; &#125; // set中加入未重复的结点 set.add(pHead); pHead = pHead.next; &#125; return null; &#125; 7. 删除链表最后K的节点12345678910111213141516171819202122232425262728293031323334353637import java.util.*;/* * public class ListNode &#123; * int val; * ListNode next = null; * public ListNode(int val) &#123; * this.val = val; * &#125; * &#125; */public class Solution &#123; /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param pHead ListNode类 * @param k int整型 * @return ListNode类 */ public ListNode FindKthToTail (ListNode pHead, int k) &#123; // write code here ListNode temp = pHead; for (int i = 0; i &lt; k; i++) &#123; if (temp == null) &#123; return temp; &#125; temp = temp.next; &#125; while (temp != null) &#123; pHead = pHead.next; temp = temp.next; &#125; return pHead; &#125;&#125; 8.删除链表倒数第n的节点12345678910111213141516171819202122232425262728293031323334import java.util.*;/* * public class ListNode &#123; * int val; * ListNode next = null; * &#125; */public class Solution &#123; /** * * @param head ListNode类 * @param n int整型 * @return ListNode类 */ public ListNode removeNthFromEnd (ListNode head, int n) &#123; // write code here ListNode temp = head; for (int i = 0; i &lt; n + 1; i++) &#123; if (temp == null) &#123; return head.next; &#125; temp = temp.next; &#125; ListNode pre = head; while (temp != null) &#123; pre = pre.next; temp = temp.next; &#125; pre.next = pre.next.next; return head; &#125;&#125; 9. 寻找两个链表公共节点1234567891011public class Solution &#123; public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; ListNode l1 = pHead1; ListNode l2 = pHead2; while (l1 != l2) &#123; l1 = (l1 == null) ? pHead2 : l1.next; l2 = (l2 == null) ? pHead1 : l2.next; &#125; return l1; &#125;&#125; 10. 链表相加例如：链表 1 为 9-&gt;3-&gt;7，链表 2 为 6-&gt;3，最后生成新的结果链表为 1-&gt;0-&gt;0-&gt;0。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.*;import java.lang.*;/* * public class ListNode &#123; * int val; * ListNode next = null; * &#125; */public class Solution &#123; /** * * @param head1 ListNode类 * @param head2 ListNode类 * @return ListNode类 */ public ListNode addInList (ListNode head1, ListNode head2) &#123; // write code here if (head1 == null) &#123; return head2; &#125; if (head2 == null) &#123; return head1; &#125; head1 = reverse(head1); head2 = reverse(head2); ListNode head = new ListNode(-1); ListNode newHead = head; int temp = 0; while (head1 != null || head2 != null) &#123; int val = temp; if (head1 != null) &#123; val += head1.val; head1 = head1.next; &#125; if (head2 != null) &#123; val += head2.val; head2 = head2.next; &#125; temp = val / 10; newHead.next = new ListNode(val % 10); newHead = newHead.next; &#125; if (temp &gt; 0) &#123; newHead.next = new ListNode(temp); &#125; return reverse(head.next); &#125; public ListNode reverse(ListNode head) &#123; ListNode rHead = new ListNode(-1); ListNode temp = head; while (temp != null) &#123; temp = temp.next; head.next = rHead.next; rHead.next = head; head = temp; &#125; return rHead.next; &#125;&#125;","categories":[],"tags":[{"name":"链表","slug":"链表","permalink":"http://duanyushuai.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"spring Validation 学习","slug":"spring validation","date":"2022-10-14T12:00:00.000Z","updated":"2022-10-18T13:42:45.571Z","comments":true,"path":"2022/10/14/spring validation/","link":"","permalink":"http://duanyushuai.github.io/2022/10/14/spring%20validation/","excerpt":"","text":"spring Validation 学习统一异常处理1234567891011121314151617181920212223@RestControllerAdvicepublic class CommonExceptionHandler &#123; @ExceptionHandler(&#123;MethodArgumentNotValidException.class&#125;) @ResponseStatus(HttpStatus.OK) @ResponseBody public Result handleMethodArgumentNotValidException(MethodArgumentNotValidException ex) &#123; BindingResult bindingResult = ex.getBindingResult(); StringBuilder sb = new StringBuilder(&quot;校验失败:&quot;); for (FieldError fieldError : bindingResult.getFieldErrors()) &#123; sb.append(fieldError.getField()).append(&quot;：&quot;).append(fieldError.getDefaultMessage()).append(&quot;, &quot;); &#125; String msg = sb.toString(); return Result.fail(BusinessCode.参数校验失败, msg); &#125; @ExceptionHandler(&#123;ConstraintViolationException.class&#125;) @ResponseStatus(HttpStatus.OK) @ResponseBody public Result handleConstraintViolationException(ConstraintViolationException ex) &#123; return Result.fail(BusinessCode.参数校验失败, ex.getMessage()); &#125;&#125; 嵌套校验某个字段也是一个对象，加Valid注解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Datapublic class UserDTO &#123; @Min(value = 10000000000000000L, groups = Update.class) private Long userId; @NotNull(groups = &#123;Save.class, Update.class&#125;) @Length(min = 2, max = 10, groups = &#123;Save.class, Update.class&#125;) private String userName; @NotNull(groups = &#123;Save.class, Update.class&#125;) @Length(min = 6, max = 20, groups = &#123;Save.class, Update.class&#125;) private String account; @NotNull(groups = &#123;Save.class, Update.class&#125;) @Length(min = 6, max = 20, groups = &#123;Save.class, Update.class&#125;) private String password; @NotNull(groups = &#123;Save.class, Update.class&#125;) @Valid private Job job; @Data public static class Job &#123; @Min(value = 1, groups = Update.class) private Long jobId; @NotNull(groups = &#123;Save.class, Update.class&#125;) @Length(min = 2, max = 10, groups = &#123;Save.class, Update.class&#125;) private String jobName; @NotNull(groups = &#123;Save.class, Update.class&#125;) @Length(min = 2, max = 10, groups = &#123;Save.class, Update.class&#125;) private String position; &#125; /** * 保存的时候校验分组 */ public interface Save &#123; &#125; /** * 更新的时候校验分组 */ public interface Update &#123; &#125;&#125; 集合校验123456789101112public class ValidationList&lt;E&gt; implements List&lt;E&gt; &#123; @Delegate // @Delegate是lombok注解 @Valid // 一定要加@Valid注解 public List&lt;E&gt; list = new ArrayList&lt;&gt;(); // 一定要记得重写toString方法 @Override public String toString() &#123; return list.toString(); &#125;&#125; controller 12345@PostMapping(&quot;/saveList&quot;)public Result saveList(@RequestBody @Validated(UserDTO.Save.class) ValidationList&lt;UserDTO&gt; userList) &#123; // 校验通过，才会执行业务逻辑处理 return Result.ok();&#125; 自定义约束注解123456789101112131415@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER&#125;)@Retention(RUNTIME)@Documented@Constraint(validatedBy = &#123;EncryptIdValidator.class&#125;)public @interface EncryptId &#123; // 默认错误消息 String message() default &quot;加密id格式错误&quot;; // 分组 Class&lt;?&gt;[] groups() default &#123;&#125;; // 负载 Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125; 实现ConstraintValidator接口编写约束校验器 1234567891011121314public class EncryptIdValidator implements ConstraintValidator&lt;EncryptId, String&gt; &#123; private static final Pattern PATTERN = Pattern.compile(&quot;^[a-f\\d]&#123;32,256&#125;$&quot;); @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; // 不为null才进行校验 if (value != null) &#123; Matcher matcher = PATTERN.matcher(value); return matcher.find(); &#125; return true; &#125;&#125; 编程式校验1Set&lt;ConstraintViolation&lt;UserDTO&gt;&gt; validate = globalValidator.validate(userDTO, UserDTO.Save.class); Validator实现原理requestBody参数校验实现原理在spring-mvc中，RequestResponseBodyMethodProcessor是用于解析@RequestBody标注的参数以及处理@ResponseBody标注方法的返回值的。显然，执行参数校验的逻辑肯定就在解析参数的方法resolveArgument()中： 1234567891011121314151617181920212223242526public class RequestResponseBodyMethodProcessor extends AbstractMessageConverterMethodProcessor &#123; @Override public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123; parameter = parameter.nestedIfOptional(); //将请求数据封装到DTO对象中 Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType()); String name = Conventions.getVariableNameForParameter(parameter); if (binderFactory != null) &#123; WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name); if (arg != null) &#123; // 执行数据校验 validateIfApplicable(binder, parameter); if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123; throw new MethodArgumentNotValidException(parameter, binder.getBindingResult()); &#125; &#125; if (mavContainer != null) &#123; mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult()); &#125; &#125; return adaptArgumentIfNecessary(arg, parameter); &#125;&#125; 可以看到，resolveArgument()调用了validateIfApplicable()进行参数校验。 1234567891011121314151617protected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) &#123; // 获取参数注解，比如@RequestBody、@Valid、@Validated Annotation[] annotations = parameter.getParameterAnnotations(); for (Annotation ann : annotations) &#123; // 先尝试获取@Validated注解 Validated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class); //如果直接标注了@Validated，那么直接开启校验。 //如果没有，那么判断参数前是否有Valid起头的注解。 if (validatedAnn != null || ann.annotationType().getSimpleName().startsWith(&quot;Valid&quot;)) &#123; Object hints = (validatedAnn != null ? validatedAnn.value() : AnnotationUtils.getValue(ann)); Object[] validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[] &#123;hints&#125;); //执行校验 binder.validate(validationHints); break; &#125; &#125;&#125; 可以看到，resolveArgument()调用了validateIfApplicable()进行参数校验。 1234567891011121314151617protected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) &#123; // 获取参数注解，比如@RequestBody、@Valid、@Validated Annotation[] annotations = parameter.getParameterAnnotations(); for (Annotation ann : annotations) &#123; // 先尝试获取@Validated注解 Validated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class); //如果直接标注了@Validated，那么直接开启校验。 //如果没有，那么判断参数前是否有Valid起头的注解。 if (validatedAnn != null || ann.annotationType().getSimpleName().startsWith(&quot;Valid&quot;)) &#123; Object hints = (validatedAnn != null ? validatedAnn.value() : AnnotationUtils.getValue(ann)); Object[] validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[] &#123;hints&#125;); //执行校验 binder.validate(validationHints); break; &#125; &#125;&#125; 看到这里，大家应该能明白为什么这种场景下@Validated、@Valid两个注解可以混用。我们接下来继续看WebDataBinder.validate()实现。 12345678@Overridepublic void validate(Object target, Errors errors, Object... validationHints) &#123; if (this.targetValidator != null) &#123; processConstraintViolations( //此处调用Hibernate Validator执行真正的校验 this.targetValidator.validate(target, asValidationGroups(validationHints)), errors); &#125;&#125; 最终发现底层最终还是调用了Hibernate Validator进行真正的校验处理。 方法级别的参数校验实现原理上面提到的将参数一个个平铺到方法参数中，然后在每个参数前面声明约束注解的校验方式，就是方法级别的参数校验。 实际上，这种方式可用于任何Spring Bean的方法上，比如Controller/Service等。其底层实现原理就是AOP，具体来说是通过MethodValidationPostProcessor动态注册AOP切面，然后使用MethodValidationInterceptor对切点方法织入增强。 1234567891011121314public class MethodValidationPostProcessor extends AbstractBeanFactoryAwareAdvisingPostProcessorimplements InitializingBean &#123; @Override public void afterPropertiesSet() &#123; //为所有`@Validated`标注的Bean创建切面 Pointcut pointcut = new AnnotationMatchingPointcut(this.validatedAnnotationType, true); //创建Advisor进行增强 this.advisor = new DefaultPointcutAdvisor(pointcut, createMethodValidationAdvice(this.validator)); &#125; //创建Advice，本质就是一个方法拦截器 protected Advice createMethodValidationAdvice(@Nullable Validator validator) &#123; return (validator != null ? new MethodValidationInterceptor(validator) : new MethodValidationInterceptor()); &#125;&#125; 接着看一下MethodValidationInterceptor： 1234567891011121314151617181920212223242526272829303132333435public class MethodValidationInterceptor implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; //无需增强的方法，直接跳过 if (isFactoryBeanMetadataMethod(invocation.getMethod())) &#123; return invocation.proceed(); &#125; //获取分组信息 Class&lt;?&gt;[] groups = determineValidationGroups(invocation); ExecutableValidator execVal = this.validator.forExecutables(); Method methodToValidate = invocation.getMethod(); Set&lt;ConstraintViolation&lt;Object&gt;&gt; result; try &#123; //方法入参校验，最终还是委托给Hibernate Validator来校验 result = execVal.validateParameters( invocation.getThis(), methodToValidate, invocation.getArguments(), groups); &#125; catch (IllegalArgumentException ex) &#123; ... &#125; //有异常直接抛出 if (!result.isEmpty()) &#123; throw new ConstraintViolationException(result); &#125; //真正的方法调用 Object returnValue = invocation.proceed(); //对返回值做校验，最终还是委托给Hibernate Validator来校验 result = execVal.validateReturnValue(invocation.getThis(), methodToValidate, returnValue, groups); //有异常直接抛出 if (!result.isEmpty()) &#123; throw new ConstraintViolationException(result); &#125; return returnValue; &#125;&#125; 实际上，不管是requestBody参数校验还是方法级别的校验，最终都是调用Hibernate Validator执行校验，Spring Validation只是做了一层封装。","categories":[{"name":"springboot","slug":"springboot","permalink":"http://duanyushuai.github.io/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://duanyushuai.github.io/tags/springboot/"}]},{"title":"springboot动态定时任务","slug":"springboot定时任务","date":"2022-10-10T12:00:00.000Z","updated":"2022-10-18T13:42:48.636Z","comments":true,"path":"2022/10/10/springboot定时任务/","link":"","permalink":"http://duanyushuai.github.io/2022/10/10/springboot%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","excerpt":"","text":"springboot动态定时任务12345678910111213141516171819202122232425262728293031323334@Data@Slf4j@Component@PropertySource(&quot;classpath:/task-config.ini&quot;)public class ScheduleTask implements SchedulingConfigurer &#123; @Value(&quot;$&#123;printTime.cron&#125;&quot;) private String cron; private Long timer = 10000L; @Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123; // 动态使用cron表达式设置循环间隔 taskRegistrar.addTriggerTask(new Runnable() &#123; @Override public void run() &#123; log.info(&quot;Current time： &#123;&#125;&quot;, LocalDateTime.now()); &#125; &#125;, new Trigger() &#123; @Override public Date nextExecutionTime(TriggerContext triggerContext) &#123; // 使用CronTrigger触发器，可动态修改cron表达式来操作循环规则// CronTrigger cronTrigger = new CronTrigger(cron);// Date nextExecutionTime = cronTrigger.nextExecutionTime(triggerContext); // 使用不同的触发器，为设置循环时间的关键，区别于CronTrigger触发器，该触发器可随意设置循环间隔时间，单位为毫秒 PeriodicTrigger periodicTrigger = new PeriodicTrigger(timer); Date nextExecutionTime = periodicTrigger.nextExecutionTime(triggerContext); return nextExecutionTime; &#125; &#125;); &#125;&#125; 除了上面的借助cron表达式的方法，还有另一种触发器，区别于CronTrigger触发器，该触发器可随意设置循环间隔时间，不像cron表达式只能定义小于等于间隔59秒","categories":[{"name":"springboot","slug":"springboot","permalink":"http://duanyushuai.github.io/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://duanyushuai.github.io/tags/springboot/"}]},{"title":"SpringSecurity","slug":"SpringSecuity","date":"2022-08-27T07:58:07.374Z","updated":"2022-08-28T06:31:55.451Z","comments":true,"path":"2022/08/27/SpringSecuity/","link":"","permalink":"http://duanyushuai.github.io/2022/08/27/SpringSecuity/","excerpt":"","text":"SpringSecuity1234 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; SpringSecurity是一个过滤器链 UsernamePasswordAuthenticationFilter: 负责填写用户名密码后的登陆请求 ExceptionTranslationFilter: 处理过滤器链中跑出的任何AccessDeniedException和AuthenticationException FilterSecurityInterceptor: 负责权限校验的过滤器","categories":[],"tags":[]},{"title":"JWT理解","slug":"Jwt理解","date":"2022-08-18T02:00:00.000Z","updated":"2022-08-28T06:35:00.527Z","comments":true,"path":"2022/08/18/Jwt理解/","link":"","permalink":"http://duanyushuai.github.io/2022/08/18/Jwt%E7%90%86%E8%A7%A3/","excerpt":"","text":"JWT理解jwt组成 标头（Header） 有效载荷（Payload） 签名（ Signature） 格式 xxx.yyy.zzz 标头令牌类型和所属签名 base64 编码 1234&#123; &quot;alg&quot;: &quot;HS256&quot; &quot;typ&quot;: &quot;jwt&quot;&#125; 有效载荷声明的实体。base64编码 12345&#123; &quot;sub&quot;: &quot;2123&quot; &quot;name&quot;: &quot;dd&quot; &quot;admin&quot;: true&#125; 签名使用密钥对header和payload进行签名，防止被容被篡改 1HMACSHA256(BASE64UrlEncode(header)+.+BASE64UrlEncode(payload),secret); 示例12345678910111213141516171819@Test public void test1()&#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); Calendar instance = Calendar.getInstance(); instance.add(Calendar.SECOND,20 ); final String username = JWT.create().withHeader(map) .withClaim(&quot;username&quot;, &quot;123&quot;) .withExpiresAt(instance.getTime()) .sign(Algorithm.HMAC256(&quot;123&quot;)); System.out.println(username ); &#125; @Test public void Test2()&#123; final JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(&quot;123&quot;)).build(); DecodedJWT verify = jwtVerifier.verify(&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2NjE1ODI2NDcsInVzZXJuYW1lIjoiMTIzIn0.b45eaJCa5uzUdGIfXfrjhw73AdzH-MXgkAI8hOY6wYU&quot;); System.out.println(verify); &#125;","categories":[{"name":"java web","slug":"java-web","permalink":"http://duanyushuai.github.io/categories/java-web/"}],"tags":[{"name":"java web","slug":"java-web","permalink":"http://duanyushuai.github.io/tags/java-web/"}]},{"title":"分布式事务","slug":"事务","date":"2022-08-14T09:48:41.791Z","updated":"2022-10-09T11:15:33.189Z","comments":true,"path":"2022/08/14/事务/","link":"","permalink":"http://duanyushuai.github.io/2022/08/14/%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"事务数据库事务特性原子性 一致性 隔离性 持久性 事务的隔离级别 Read uncommitted 读未提交读 ，读到其他事务未提交的数据，脏读 Read committed 读提交读，读到另一个事务的提交数据，在一个事务中，读取的数据不一样，形成不可重复读 Repeatable read mysql 默认的隔离级别，在同一个事务里，select 的结果是事务开始时时间点的状态，因此，同样的 select 操作读到的结果会是一致的，但是，会有幻读现象。MySQL 的 InnoDB 引擎可以通过 next-key locks 机制来避免幻读。 Serializable 序列化 事务的传播行为1、PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务， 就加入该事务，该设置是最常用的设置。 2、PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当 前不存在事务，就以非事务执行。 3、PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果 当前不存在事务，就抛出异常。 4、PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。 5、PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当 前事务挂起。 6、PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。 7、PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务， 则执行与 PROPAGATION_REQUIRED 类似的操作。 同一个对象内事务方法互相调失效，原因绕过了代理对象 解决：使用代理对象来调用事务方法 1）、引入aop-starter;spring-boot-starter-aop; 引入aspectj 2）、@EnableAspectJAutoProxy; 开启 aspectj 动态代理功能，以后的代理对象都是aspectj 0）、导入 spring-boot-starter-aop 1）、@EnableTransactionManagement(proxyTargetClass &#x3D; true) 2）、@EnableAspectJAutoProxy(exposeProxy&#x3D;true) 3）、AopContext.currentProxy() 调用方法 分布式事务CAP 原理CAP 原则又称 CAP 定理，指的是在一个分布式系统中 一致性（Consistency）： 在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本） 可用性（Availability） 在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据 更新具备高可用性） 分区容错性（Partition tolerance） 大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（ partition）。 分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。 CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。 一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们， 剩下的 C 和 A 无法同时做到。 分布式系统中实现一致性的 raft 算法、paxos http://thesecretlivesofdata.com/raft/ 分布式事务解决方案2PC模式数据库支持的 2PC【2 phase commit 二阶提交】，又叫做 XA Transactions。 MySQL 从 5.5 版本开始支持，SQL Server 2005 开始支持，Oracle 7 开始支持。 其中，XA 是一个两阶段提交协议，该协议分为以下两个阶段： 第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是 否可以提交. 第二阶段：事务协调器要求每个数据库提交数据。 其中，如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务 中的那部分信息。 XA 协议比较简单，而且一旦商业数据库实现了 XA 协议，使用分布式事务的成本也比较 低。 XA 性能不理想，特别是在交易下单链路，往往并发量很高，XA 无法满足高并发场景 XA 目前在商业数据库支持的比较理想，在 mysql 数据库中支持的不太理想，mysql 的 XA 实现，没有记录 prepare 阶段日志，主备切换回导致主库与备库数据不一致。 许多 nosql 也没有支持 XA，这让 XA 的应用场景变得非常狭隘。 也有 3PC，引入了超时机制（无论协调者还是参与者，在向对方发送请求后，若长时间 未收到回应则做出相应处理） 柔性事务 TCC 事务补偿型方案刚性事务：遵循 ACID 原则，强一致性。 柔性事务：遵循 BASE 理论，最终一致性； 与刚性事务不同，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致。 柔性事务 最大努力通知方案按规律进行通知，不保证数据一定能通知成功，但会提供可查询操作接口进行核对。这种 方案主要用在与第三方系统通讯时，比如：调用微信或支付宝支付后的支付结果通知。这种 方案也是结合 MQ 进行实现，例如：通过 MQ 发送 http 请求，设置最大通知次数。达到通 知次数后即不再通知。 案例：银行通知、商户通知等（各大交易业务平台间的商户通知：多次通知、查询校对、对 账文件），支付宝的支付成功异步回调 柔性事务 + 可靠消息 + 最终一致性实现：业务处理服务在业务事务提交之前，向实时消息服务请求发送消息，实时消息服务只 记录消息数据，而不是真正的发送。业务处理服务在业务事务提交之后，向实时消息服务确 认发送。只有在得到确认发送指令后，实时消息服务才会真正发送。 seata 每一个服务创建数据表 undo_log 安装事务协调器：seata-server : http://github.com/seata/seata/releases 整合 1）导入依赖 spring-cloud-starter-alibaba-seata 2）解压并启动seata-server： ​ Registry.conf: 注册中心配置 3）配置代理数据源 4）每个微服务导入 registry.conf file.conf vgroup_mapping.{application.name}-fescar-service-group &#x3D; “default” ​ 5) 加globaTransactional","categories":[],"tags":[]},{"title":"接口幂等性","slug":"接口幂等性","date":"2022-08-10T02:00:00.000Z","updated":"2022-08-11T14:06:32.123Z","comments":true,"path":"2022/08/10/接口幂等性/","link":"","permalink":"http://duanyushuai.github.io/2022/08/10/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/","excerpt":"","text":"接口幂等性问题出现 用户多次点击 用户回退在提交 feign触发重试 1.token token 的获取、比较和删除必须是原子性的 使用redis和lua脚本 1if redis.call(&#x27;get&#x27;,KEYS[1]== ARGV[1] then return is.call(&#x27;del&#x27;,KEYS[1])) else return 0 end 2. 各种锁机制1. 数据库悲观锁1select * from xxxx where id=1 for update id一定是主键和唯一索引，不然可能造成锁表 2. 数据库乐观锁首先获取这条数据的版本号version，然后操作的时候带上版本号 1update goods set count = count -1 ,version = version + 1 where id = 2 and version = 1 乐观锁处理读多写少问题 3. 业务分布式锁4. 各种唯一索引数据库的唯一约束插入数据按照唯一索引，比如订单号，相同的订单号就不能重复插入。需要不是自增主键，代码生成全局唯一id。 在分库分表下，根据路由规则，要路由到同一张表，才能是唯一索引有意义。 redis防重我们可以计算上传数据的MD5值，存到redis set，每次处理数据，去和redis进行匹配 防重表把orderNo作为去重表的唯一索引插入mysql，去重表和业务表处在同一数据库，处于同一事务，方便回滚 5.全局请求唯一id调用接口生成唯一id，保存在redis的集合中。 可以使用nginx设置请求的唯一id 1proxy_set_header X-Request-Id $request_id;","categories":[{"name":"java web","slug":"java-web","permalink":"http://duanyushuai.github.io/categories/java-web/"}],"tags":[{"name":"java web","slug":"java-web","permalink":"http://duanyushuai.github.io/tags/java-web/"}]},{"title":"redis 缓存","slug":"redis 缓存","date":"2022-07-11T13:46:55.260Z","updated":"2022-07-12T13:52:10.751Z","comments":true,"path":"2022/07/11/redis 缓存/","link":"","permalink":"http://duanyushuai.github.io/2022/07/11/redis%20%E7%BC%93%E5%AD%98/","excerpt":"","text":"redis 缓存那些数据适合缓存 即时性和数据一致性要求不高的 读多写少 使用redis 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 简单的分布式锁 12345678910111213141516171819202122232425262728293031323334353637383940public Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatalogJsonFromDbWithRedislock() &#123; // 1 占分布式锁，去redis占坑 String uuid = UUID.randomUUID().toString(); Boolean lock = redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, uuid, 300, TimeUnit.SECONDS); if (lock) &#123; System.out.println(&quot;获取分布式锁成功&quot;); // 加锁成功...执行业务 // 2 设置过期时间// redisTemplate.expire(&quot;lock&quot;, 30, TimeUnit.SECONDS); Map&lt;String, List&lt;Catelog2Vo&gt;&gt; dataFromDB; try &#123; dataFromDB = getDataFromDB(); &#125; finally &#123; String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;; // 删除锁 Long lock1 = redisTemplate.execute(new DefaultRedisScript&lt;Long&gt;(script, Long.class), Arrays.asList(&quot;lock&quot;), uuid); &#125;// redisTemplate.delete(&quot;lock&quot;); // 获取值对比 + 对比成功删除 = 原子操作 lua脚本解锁// String lockValue = redisTemplate.opsForValue().get(&quot;lock&quot;);// if (uuid.equals(lockValue)) &#123;// // 删除我自己的锁// redisTemplate.delete(&quot;lock&quot;);// &#125; return dataFromDB; &#125; else &#123; // 加锁失败 // 休眠100ms重试 System.out.println(&quot;获取分布式锁失败...等待重试&quot;); try &#123; Thread.sleep(200); &#125; catch (Exception e) &#123; &#125; return getCatalogJsonFromDbWithRedislock(); // 自旋的方式 &#125; &#125;","categories":[],"tags":[]},{"title":"nginx使用","slug":"nginx使用","date":"2022-07-02T10:30:26.308Z","updated":"2022-07-02T10:34:50.961Z","comments":true,"path":"2022/07/02/nginx使用/","link":"","permalink":"http://duanyushuai.github.io/2022/07/02/nginx%E4%BD%BF%E7%94%A8/","excerpt":"","text":"nginx使用","categories":[],"tags":[]},{"title":"sku和spu数据库设计","slug":"sku和spu数据库设计","date":"2022-06-26T10:50:48.206Z","updated":"2022-07-03T02:56:31.206Z","comments":true,"path":"2022/06/26/sku和spu数据库设计/","link":"","permalink":"http://duanyushuai.github.io/2022/06/26/sku%E5%92%8Cspu%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"sku和spu数据库设计","categories":[],"tags":[]},{"title":"自定义注解","slug":"自定义注解（校验和日志）","date":"2022-06-26T03:34:51.020Z","updated":"2022-07-02T07:51:02.580Z","comments":true,"path":"2022/06/26/自定义注解（校验和日志）/","link":"","permalink":"http://duanyushuai.github.io/2022/06/26/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%EF%BC%88%E6%A0%A1%E9%AA%8C%E5%92%8C%E6%97%A5%E5%BF%97%EF%BC%89/","excerpt":"","text":"自定义注解（校验和日志）JSR303 自定义校验创建ListValue校验注解123456789101112131415161718192021222324252627package com.yxj.gulimall.common.valid;import javax.validation.Constraint;import javax.validation.Payload;import java.lang.annotation.*;/** * * 自定义校验注解 */@Documented@Constraint( validatedBy = &#123;ListValueConstraintValidator.class&#125;)@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ListValue &#123; String message() default &quot;&#123;com.chenxin.gulimail.common.valid.ListValue.message&#125;&quot;; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; int[] vals() default &#123;&#125;;&#125; ListValueConstraintValidator校验器1234567891011121314151617181920212223242526&#123; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); /** * 初始化 * @param constraintAnnotation */ @Override public void initialize(ListValue constraintAnnotation) &#123; int[] vals = constraintAnnotation.vals(); for (int val : vals) &#123; set.add(val); &#125; &#125; /** * 真正的校验规则 * 判断是否校验成功 * @param integer * @param constraintValidatorContext * @return */ @Override public boolean isValid(Integer integer, ConstraintValidatorContext constraintValidatorContext) &#123; return set.contains(integer); &#125;&#125;","categories":[],"tags":[]},{"title":"redis Guava 缓存","slug":"redis-Guava-缓存","date":"2022-06-26T02:00:00.000Z","updated":"2022-07-24T13:18:01.257Z","comments":true,"path":"2022/06/26/redis-Guava-缓存/","link":"","permalink":"http://duanyushuai.github.io/2022/06/26/redis-Guava-%E7%BC%93%E5%AD%98/","excerpt":"","text":"redis Guava 缓存redis 懒加载数据在新增到 MySQL 不进行缓存，在精确查找进行缓存，做到查询即缓存，不查询不缓存。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// 伪代码示例 Xx代表你的的业务对象 如User Goods等等public class XxLazyCache &#123; @Autowired private RedisTemplate&lt;String, Xx&gt; redisTemplate; @Autowired private XxService xxService;// 你的业务service /** * 查询 通过查询缓存是否存在驱动缓存加载 建议在前置业务保证id对应数据是绝对存在于数据库中的 */ public Xx getXx(int id) &#123; // 1.查询缓存里面有没有数据 Xx xxCache = getXxFromCache(id); if(xxCache != null) &#123; return xxCache;// 卫语句使代码更有利于阅读 &#125; // 2.查询数据库获取数据 我们假定到业务这一步，传过来的id都在数据库中有对应数据 Xx xx = xxService.getXxById(id); // 3.设置缓存、这一步相当于Redis缓存懒加载，下次再查询此id，则会走缓存 setXxFromCache(xx); return xx; &#125; &#125; /** * 对xx数据进行修改或者删除操作 操作数据库成功后 删除缓存 * 删除请求 - 删除数据库数据 删除缓存 * 修改请求 - 更新数据库数据 删除缓存 下次在查询时候就会从数据库拉取新的数据到缓存中 */ public void deleteXxFromCache(long id) &#123; String key = &quot;Xx:&quot; + xx.getId(); redisTemplate.delete(key); &#125; private void setXxFromCache(Xx xx) &#123; String key = &quot;Xx:&quot; + xx.getId(); redisTemplate.opsForValue().set(key, xx); &#125; private Xx getXxFromCache(int id) &#123; // 通过缓存前缀拼装唯一主键作为缓存Key 如Xxx信息 就是Xxx:id String key = &quot;Xx:&quot; + id; return redisTemplate.opsForValue().get(key); &#125;&#125;// 业务类public class XxServie &#123; @Autowired private XxLazyCache xxLazyCache; // 查询数据库 public Xx getXxById(long id) &#123; // 省略实现 return xx; &#125; public void updateXx(Xx xx) &#123; // 更新MySQL数据 省略 // 删除缓存 xxLazyCache.deleteXxFromCache(xx.getId()); &#125; public void deleteXx(long id) &#123; // 删除MySQL数据 省略 // 删除缓存 xxLazyCache.deleteXxFromCache(xx.getId()); &#125;&#125;// 实体类@Datapublic class Xx &#123; // 业务主键 private Long id; // ...省略&#125;","categories":[{"name":"Guava","slug":"Guava","permalink":"http://duanyushuai.github.io/categories/Guava/"},{"name":"redis","slug":"Guava/redis","permalink":"http://duanyushuai.github.io/categories/Guava/redis/"}],"tags":[{"name":"Guava","slug":"Guava","permalink":"http://duanyushuai.github.io/tags/Guava/"},{"name":"redis","slug":"redis","permalink":"http://duanyushuai.github.io/tags/redis/"}]},{"title":"解决跨域","slug":"解决跨域","date":"2022-06-25T09:57:38.465Z","updated":"2022-08-14T04:28:49.153Z","comments":true,"path":"2022/06/25/解决跨域/","link":"","permalink":"http://duanyushuai.github.io/2022/06/25/%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/","excerpt":"","text":"解决跨域 使用nginx部署为同一域 请求返回可跨域","categories":[{"name":"java web","slug":"java-web","permalink":"http://duanyushuai.github.io/categories/java-web/"}],"tags":[{"name":"java web","slug":"java-web","permalink":"http://duanyushuai.github.io/tags/java-web/"}]},{"title":"","slug":"Duan","date":"2022-06-12T09:02:04.255Z","updated":"2022-06-13T00:32:33.427Z","comments":true,"path":"2022/06/12/Duan/","link":"","permalink":"http://duanyushuai.github.io/2022/06/12/Duan/","excerpt":"","text":"Duantest","categories":[],"tags":[]},{"title":"api接口优化","slug":"api接口优化","date":"2022-06-07T02:00:00.000Z","updated":"2022-08-14T04:29:34.848Z","comments":true,"path":"2022/06/07/api接口优化/","link":"","permalink":"http://duanyushuai.github.io/2022/06/07/api%E6%8E%A5%E5%8F%A3%E4%BC%98%E5%8C%96/","excerpt":"","text":"api 接口调优慢查询1.深度分页1select name,code from student limit 1000,20 会查出来前1000条数据 1select name,code from student where id &gt; 1000 limit 20 走索引，但需要上次查询出来的最大id 2.未加索引1show create table xxxx (表名) 查看表索引 加索引表可能引起锁表，要在mysql使用低峰期 3.索引失效索引失效的几个原因 索引字段的区分度不大 索引语句在or中 模糊匹配 %xxx 索引发生隐式变换 不满足最左前缀规则 where条件里，索引有计算 4.join 过多or子查询过多一般不建议用子查询，可以把子查询改成join，join的表也不宜过多，具体问题具体分析，看数据量 5.in的元素过多如果一个查询有in ，in条件加了合适的索引，还是慢，就高度怀疑是in的元素过多。可以分组查询，再快可以引用多线程 in元素过多可以在代码层做限制 123if(ids.size() &gt; 200) &#123; throw new Exception(&quot;单次查询数据量太多&quot;)&#125; 6.单纯数据量过大分库分表 业务复杂1.循环调用循环调用同一段代码，每次的循环逻辑一致，前后不关联。比如我们要初始化一个列表。 可采用多线程的方式去获取数据 2. 顺序调用 使用CompletableFuture解决 3. 线程池设置不合理调整线程池参数，查看时候是io任务还是cpu任务，根据业务来拆分线程池。 4. 锁设置并不合理锁类型使用不合理，就是读写锁。锁粒度太大 5.机器问题（fullGC，机器重启，线程打满）造成这个问题的原因非常多，笔者就遇到了定时任务过大引起fullGC，代码存在线程泄露引起RSS内存占用过高进而引起机器重启等待诸多原因。需要结合各种监控和具体场景具体分析，进而进行大事务拆分、重新规划线程池等等工作 6. 万金油解决方式 缓存 简单的map guava等本地缓存工具包 缓存中间件：redis、tair或memcached 回调和反查 ​ 这种方式往往是业务上的解决方式，在订单或者付款系统中应用的比较多。举个例子：当我们付款的时候，需要调用一个专门的付款系统接口，该系统经过一系列验证、存储工作后还要调用银行接口以执行付款。由于付款这个动作要求十分严谨，银行侧接口执行可能比较缓慢，进而拖累整个付款接口性能。 ​ 这个时候我们就可以采用fast success的方式：当必要的校验和存储完成后，立即返回success，同时告诉调用方一个中间态“付款中”。而后调用银行接口，当获得支付结果后再调用上游系统的回调接口返回付款的最终结果“成果”or“失败”。","categories":[{"name":"java web","slug":"java-web","permalink":"http://duanyushuai.github.io/categories/java-web/"}],"tags":[{"name":"java web","slug":"java-web","permalink":"http://duanyushuai.github.io/tags/java-web/"}]},{"title":"二分查找","slug":"二分查找","date":"2022-04-22T02:00:00.000Z","updated":"2022-11-03T09:31:31.148Z","comments":true,"path":"2022/04/22/二分查找/","link":"","permalink":"http://duanyushuai.github.io/2022/04/22/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"二分查找&#x2F;排序1. 二分查找12345678910111213141516171819202122232425262728import java.util.*;public class Solution &#123; /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param nums int整型一维数组 * @param target int整型 * @return int整型 */ public int search (int[] nums, int target) &#123; int l = 0; int r = nums.length - 1; while (l &lt;= r) &#123; int m = (l + r) / 2; if (nums[m] == target) &#123; return m; &#125; if (nums[m] &gt; target) r = m - 1; else l = m + 1; &#125; return -1; &#125;&#125; 2. 归并排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Sort &#123; public static void MergeSort(int[] arr, int low, int high) &#123; //使用递归的方式进行归并排序，所需要的空间复杂度是O（N+logN） int mid = (low + high)/2; if(low &lt; high) &#123; //递归地对左右两边进行排序 MergeSort(arr, low, mid); MergeSort(arr, mid+1, high); //合并 merge(arr, low, mid, high); &#125; &#125; //merge函数实际上是将两个有序数组合并成一个有序数组 //因为数组有序，合并很简单，只要维护几个指针就可以了 private static void merge(int[] arr, int low, int mid, int high) &#123; //temp数组用于暂存合并的结果 int[] temp = new int[high - low + 1]; //左半边的指针 int i = low; //右半边的指针 int j = mid+1; //合并后数组的指针 int k = 0; //将记录由小到大地放进temp数组 for(; i &lt;= mid &amp;&amp; j &lt;= high; k++) &#123; if(arr[i] &lt; arr[j]) temp[k] = arr[i++]; else temp[k] = arr[j++]; &#125; //接下来两个while循环是为了将剩余的（比另一边多出来的个数）放到temp数组中 while(i &lt;= mid) temp[k++] = arr[i++]; while(j &lt;= high) temp[k++] = arr[j++]; //将temp数组中的元素写入到待排数组中 for(int l = 0; l &lt; temp.length; l++) arr[low + l] = temp[l]; &#125; &#125; 3.快速排序123456789101112131415161718192021222324252627282930313233343536373839public class QuickSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return quickSort(arr, 0, arr.length - 1); &#125; private int[] quickSort(int[] arr, int left, int right) &#123; if (left &lt; right) &#123; int partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); &#125; return arr; &#125; private int partition(int[] arr, int left, int right) &#123; // 设定基准值（pivot） int pivot = left; int index = pivot + 1; for (int i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr, pivot, index - 1); return index - 1; &#125; private void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://duanyushuai.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://duanyushuai.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"docker入门","slug":"docker","date":"2022-03-02T02:00:00.000Z","updated":"2022-06-21T02:24:27.154Z","comments":true,"path":"2022/03/02/docker/","link":"","permalink":"http://duanyushuai.github.io/2022/03/02/docker/","excerpt":"","text":"docker1234567891011121314151617181920212223242526272829301. 卸载系统之前的docker sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine2.$ sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm23. sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 4. 安装DOCKER引擎sudo yum install docker-ce docker-ce-cli containerd.io5. 启动Docker.sudo systemctl start docker6. 设置开机自启sudo systemctl start docker7. 阿里云镜像加速器https://cr.console.aliyun.com/cn-wulanchabu/instances/mirrors docker 使用123456789101112131415161718192021222324252627282930313233343536373839404142434445sudo docker pull mysql:8.0docker images创建目录保存数据sudo docker run --name mysql -v /usr/local/mysql/data:/var/lib/mysql -v /usr/local/mysql:/etc/mysql/conf.d -v /usr/local/mysql/log:/var/log/mysql -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d mysql:8.0## -v 目录映射，可以在linux环境中寻找文件，修改容器配置查看运行容器docker ps[root@hecs-328722 mysql]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES369ccdfb7630 mysql:8.0 &quot;docker-entrypoint.s…&quot; 6 minutes ago Up 6 minutes 0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp mysql进入容器 内部docker exec -it 容器名称|容器id bin/bashdocker exec -it mysql bin/bash退出容器exit1. 安装redisdocker pull redis:6.0.102. 修改需要自定义的配置(docker-redis默认没有配置文件，自己在宿主机建立后挂载映射)创建并修改/usr/local/redis/redis.confbind 0.0.0.0 开启远程权限appendonly yes 开启aof持久化3.docker run --name redis -v /usr/local/redis/data:/data -v /usr/local/redis/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 -d redis:6.0.10 redis-server /usr/local/etc/redis/redis.conf 解释： -v /usr/local/redis/data:/data # 将数据目录挂在到本地保证数据安全 -v /root/redis/redis.conf:/usr/local/etc/redis/redis.conf # 将配置文件挂在到本地修改方便 4. docker 起客户端 docker exec -it redis redis-cli 5. 重启redis docker restart redis","categories":[{"name":"docker","slug":"docker","permalink":"http://duanyushuai.github.io/categories/docker/"},{"name":"谷粒商城","slug":"docker/谷粒商城","permalink":"http://duanyushuai.github.io/categories/docker/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://duanyushuai.github.io/tags/docker/"}]},{"title":"视频工具","slug":"工具","date":"2022-02-22T02:00:00.000Z","updated":"2022-08-28T06:39:49.980Z","comments":true,"path":"2022/02/22/工具/","link":"","permalink":"http://duanyushuai.github.io/2022/02/22/%E5%B7%A5%E5%85%B7/","excerpt":"","text":"工具你有没有想过，在自己常用的网站地址前加几个字符，就可以实现各种各样的效果？ 无需安装任何软件，就能解析视频、下载音乐、复制文库……是的你没看错，只需要简单地添加一个前缀，就能解决。 视频解析 找到你喜欢的电影&#x2F;电视剧，打开它所在当前网页。 不论是爱奇艺，腾讯视频还是其他视频网站，只需要在网站前加上wn.run&#x2F;这串字符。 注意：一定要在http或https前面添加。 然后按下回车，就会跳转至一个名为万能命令的新页面。 在下方【相关视频播放】这一栏里，就是你想观看的视频的解析结果。 任选一个解析网站打开，就可以全屏观看该视频了。 文库下载 对于工作党和学生党来说，最痛苦的事情，莫过于找到了急需的资料，却没有文库VIP了。 在某度文库上，如果没有开通VIP的话，既无法复制文字，也无法下载文档，几乎是寸步难行。 这时候，我们只需要在所需文档地址前加上wn.run&#x2F;前缀。 按下回车，就可以找到文库在线下载的解析结果了。 点击上述结果，即会自动跳转至一个名为网页转换助手的页面。 在这里，你可以选择【转为Word】或【转为PDF】。 然后点击【下载】按钮，就能成功下载该会员文档的源文件了。 音乐下载 如果想要下载网易云音乐、QQ音乐、酷狗音乐上的歌曲，只需在播放地址前加上wn.run&#x2F;。 然后选择其中一个解析源，就能下载歌曲了。 视频下载 当然，这个小技巧不仅能用于下载音乐，同时也可以用来下载各个视频网站上的视频。 以B站为例，在网址前输入wn.run&#x2F;。 然后回车，选择其中一个解析结果，就可以成功下载该视频了。 除了上面介绍的功能，通过wn.run&#x2F;这个命令还能实现许许多多的效果，比如网页翻译、网页截图、网页二维码生成等等。 每个功能都无需下载、即用即走，且没有平台限制，pc、android、ios等都可使用。 另外，在万能命令网站里，还收录了很多高质量的工具，大家感兴趣的话，也可以直接收藏这个地址。 鉴于这个工具比较敏感，如果大家有需要的话，就赶紧试试吧！","categories":[{"name":"工具","slug":"工具","permalink":"http://duanyushuai.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://duanyushuai.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"rabbitMQ","slug":"rabbitMQ","date":"2022-02-20T02:00:00.000Z","updated":"2022-09-22T14:09:44.555Z","comments":true,"path":"2022/02/20/rabbitMQ/","link":"","permalink":"http://duanyushuai.github.io/2022/02/20/rabbitMQ/","excerpt":"","text":"rabbitMQ 延迟队列 可以实现为","categories":[{"name":"rabbitMQ","slug":"rabbitMQ","permalink":"http://duanyushuai.github.io/categories/rabbitMQ/"}],"tags":[{"name":"rabbitMQ","slug":"rabbitMQ","permalink":"http://duanyushuai.github.io/tags/rabbitMQ/"}]},{"title":"全局异常","slug":"全局异常","date":"2021-10-11T02:00:00.000Z","updated":"2022-08-14T04:29:18.719Z","comments":true,"path":"2021/10/11/全局异常/","link":"","permalink":"http://duanyushuai.github.io/2021/10/11/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8/","excerpt":"","text":"全局异常12345678910111213141516171819202122@Slf4j@RestControllerAdvice(basePackages = &quot;com.yxj.gulimall.product.controller&quot;)public class GulimallExceptionControllerAdvice &#123; @ExceptionHandler(value = MethodArgumentNotValidException.class) public R handleValidException(MethodArgumentNotValidException e) &#123; log.error(&quot;数据校验出现问题&#123;&#125;,异常类型: &#123;&#125;&quot;,e.getMessage(),e.getClass()); BindingResult bindingResult = e.getBindingResult(); Map&lt;String, String&gt; errorMap = new HashMap&lt;&gt;(); bindingResult.getFieldErrors().forEach((fieldError -&gt; &#123; errorMap.put(fieldError.getField(),fieldError.getDefaultMessage()); &#125;)); return R.error(BizCodeEnum.VALID_EXCEPTION.getCode(),BizCodeEnum.VALID_EXCEPTION.getMsg()).put(&quot;data&quot;,errorMap); &#125; @ExceptionHandler(value = Throwable.class) public R handleException(Throwable throwable) &#123; log.error(&quot;错误:&quot;, throwable); return R.error(BizCodeEnum.UNKNOWN_EXCEPTION.getCode(),BizCodeEnum.UNKNOWN_EXCEPTION.getMsg()); &#125;&#125;","categories":[],"tags":[]},{"title":"HashMap","slug":"HashMap","date":"2021-07-08T03:00:23.000Z","updated":"2022-06-18T07:38:31.348Z","comments":true,"path":"2021/07/08/HashMap/","link":"","permalink":"http://duanyushuai.github.io/2021/07/08/HashMap/","excerpt":"","text":"HashMapjdk1.7 数组+链表 jdk1.8 数组+ 链表&#x2F;红黑树 DEFAULT_INITIAL_CAPACITY Table数组的初始化长度： 1 &lt;&lt; 4``2^4=16（为什么要是 2的n次方？） MAXIMUM_CAPACITY Table数组的最大长度： 1&lt;&lt;30``2^30=1073741824 DEFAULT_LOAD_FACTOR 负载因子：默认值为0.75。 当元素的总个数&gt;当前数组的长度 * 负载因子。数组会进行扩容，扩容为原来的两倍（todo：为什么是两倍？） TREEIFY_THRESHOLD 链表树化阙值： 默认值为 8 。表示在一个node（Table）节点下的值的个数大于8时候，会将链表转换成为红黑树。 UNTREEIFY_THRESHOLD 红黑树链化阙值： 默认值为 6 。 表示在进行扩容期间，单个Node节点下的红黑树节点的个数小于6时候，会将红黑树转化成为链表。 MIN_TREEIFY_CAPACITY = 64 最小树化阈值，当Table所有元素超过改值，才会进行树化（为了防止前期阶段频繁扩容和树化过程冲突） HashMap是线程不安全的","categories":[{"name":"java","slug":"java","permalink":"http://duanyushuai.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://duanyushuai.github.io/tags/java/"},{"name":"HashMap","slug":"HashMap","permalink":"http://duanyushuai.github.io/tags/HashMap/"}]},{"title":"Java高并发程序设计第二章","slug":"Java高并发程序设计第二章","date":"2021-06-07T03:00:23.000Z","updated":"2022-06-13T15:00:55.975Z","comments":true,"path":"2021/06/07/Java高并发程序设计第二章/","link":"","permalink":"http://duanyushuai.github.io/2021/06/07/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%BA%8C%E7%AB%A0/","excerpt":"","text":"Java高并发程序设计第二章线程创建4个方法创建线程4个方法 继承Thread类创建线程 1234567public class MyThread extends Thread&#123;//继承Thread类 public void run()&#123; //重写run方法 &#125;&#125;new MyThread().start();//创建并启动线程 实现Runnable接口创建线程 12345678910111213141516public class MyThread2 implements Runnable &#123;//实现Runnable接口 public void run()&#123; //重写run方法 &#125;&#125;public class Main &#123; public static void main(String[] args)&#123; //创建并启动线程 MyThread2 myThread=new MyThread2(); Thread thread=new Thread(myThread); thread().start(); //或者 new Thread(new MyThread2()).start(); &#125;&#125; 使用Callable和Future创建线程 123456789101112131415public static void main(String[] args) &#123; // 先使用Lambda表达式创建Callable&lt;Integer&gt;对象 // 使用FutureTask来包装Callable对象 FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;((Callable&lt;Integer&gt;)() -&gt; 5); new Thread(task).start(); try &#123; System.out.println(&quot;子线程的返回值：&quot; + task.get()); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; 使用线程池例如用Executor框架 线程中断 禁止用stop()来退出线程，不安全。 线程安全退出，与中断有关的三个方法。 123public void Thread.interrupt() // 中断线程public boolean Thread.isInterrupted() // 判断是否被中断public static boolean Thread.interrupted() // 判断是否被中断，并清除当前中断状态 等待wait和通知notify 这两个⽅法并不是在Thread类中 的，⽽是输出Object类。 Object.wait()和Thread.sleep()方法都可以让线程等待若干时 间。除了wait()可以被唤醒外，另外一个主要区别就是wait()方法会 释放目标对象的锁，而Thread.sleep()方法不会释放任何资源。 等待线程结束（join)和谦让(yield)12345678910111213141516public class JoinMain &#123; public volatile static int i=0; public static class AddThread extends Thread&#123; @Override public void run() &#123; for(i=0;i&lt;1111111;i++); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; AddThread at=new AddThread(); at.start(); at.join(); System.out.println(i); &#125;&#125; join()d的核心代码段 123while (isAlive()) &#123; wait(0);&#125; 可以看到，它让调⽤线程在当前线程对象上进⾏等待。当线程执 ⾏完成后，被等待的线程会在退出前调⽤notifyAll()通知所有的等待线 程继续执⾏。因此，值得注意的⼀点是：不要在应⽤程序中，在 Thread对象实例上使⽤类似wait()或者notify()等⽅法，因为这很有可能 会影响系统API的⼯作，或者被系统API所影响。 守护线程(Daemon)如垃圾回收线程 12345678910111213141516171819202122232425262728package testdemo;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class DaemonDemo &#123; private static final Logger logger = LoggerFactory.getLogger(DaemonDemo.class); public static class DaemonT extends Thread&#123; @Override public void run()&#123; while (true)&#123; logger.info(&quot;I am alive&quot;); try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; DaemonT d = new DaemonT(); d.setDaemon(true); d.start(); &#125;&#125; d线程为main线程的守护线程，main一结束，d立即结束。 线程优先级设置1234Thread high=new HightPriority();LowPriority low=new LowPriority();high.setPriority(Thread.MAX_PRIORITY);low.setPriority(Thread.MIN_PRIORITY);","categories":[{"name":"java","slug":"java","permalink":"http://duanyushuai.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://duanyushuai.github.io/tags/java/"}]},{"title":"joda-time、日志、代码规范","slug":"joda-time  日志  代码规范","date":"2021-04-07T03:00:23.000Z","updated":"2022-06-13T15:02:06.174Z","comments":true,"path":"2021/04/07/joda-time  日志  代码规范/","link":"","permalink":"http://duanyushuai.github.io/2021/04/07/joda-time%20%20%E6%97%A5%E5%BF%97%20%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/","excerpt":"","text":"joda-time 日志 代码规范jode-time1234567891011121314@Test public void dateDemo()&#123; DateTime dt = new DateTime(2015,9,1,12,30,0); Date d = dt.toDate(); //当天起始日期 DateTime today = DateTime.now().withTimeAtStartOfDay(); //三天后的日期 DateTime dateTime = today.plusDays(3).plusMonths(1); //入住时间和离店时间的差值 DateTime checkIn = new DateTime(2015,8,29,0,0,0); DateTime checkOut = new DateTime(2015,9,2,0,0,0); System.out.println(Days.daysBetween(checkIn,checkOut).getDays()); &#125; 日期格式 123456789public class DateTimeExample1 &#123; private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormat.forPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;); public static void main(String[] args) &#123; System.out.println(DATE_TIME_FORMATTER.print(new DateTime())); System.out.println(DATE_TIME_FORMATTER.parseDateTime(&quot;2000-01-01 12:12:12&quot;).toDate()); &#125;&#125; 日志规范配置 123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 实例 123456789101112public class LogTest &#123; private static final Logger logger = LoggerFactory.getLogger(LogTest.class); public static void main(String[] args) &#123; logger.trace(&quot;log in trace level,args:&#123;&#125;&quot;,args); logger.debug(&quot;log in trace level,args:&#123;&#125;&quot;,args); logger.info(&quot;log in trace level,args:&#123;&#125;&quot;,args); logger.warn(&quot;log in trace level,args:&#123;&#125;&quot;,args); logger.error(&quot;log in trace level,args:&#123;&#125;&quot;,args); &#125;&#125; 查看日志 登录跳板机 在跳板机登录服务器 进入应用目录，一般为&#x2F;home&#x2F;q&#x2F;www&#x2F;&lt;应用名&gt;&#x2F; 该目录下有logs目录，其中存放了Tomcat日志，catalina.out记录了打印到控制台的日志，一般来说，查看改日志即可。 日志规范 禁止使用System.out.print() 在异常处理中打印关键信息 入参 关键变量值 注意数据保密 与用户相关的信息保密 打码到日志 不能影响正常业务 打印日志不能抛出异常，不能影响正常业务 日志影响性能，高QPS业务，控制日志输出量。 使用占位符代替字符串拼接 123456789public class LogTest &#123; private static final Logger logger = LoggerFactory.getLogger(LogTest.class); public static void main(String[] args) &#123; String s = &quot;111&quot;; logger.info(&quot;log in trace level,args: &#123;&#125;&quot;,args); logger.info(&quot;log in trace level,args: &#123;&#125; , &#123;&#125;&quot;,s,s.length()); &#125;&#125; 代码规范 代码给以后的自己看 强迫症 书《编写可读代码的艺术》 类名：形容词或动词 方法名：动词 注释 使用Javadoc格式编写注释 接口必须有注释，对参数，返回值有说明。例如参数限制，返回值是否为空，接口调用频率。","categories":[{"name":"java","slug":"java","permalink":"http://duanyushuai.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://duanyushuai.github.io/tags/java/"}]},{"title":"线程创建4个方法","slug":"线程创建4个方法","date":"2021-04-07T03:00:23.000Z","updated":"2022-06-13T15:00:03.170Z","comments":true,"path":"2021/04/07/线程创建4个方法/","link":"","permalink":"http://duanyushuai.github.io/2021/04/07/%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA4%E4%B8%AA%E6%96%B9%E6%B3%95/","excerpt":"","text":"线程创建4个方法创建线程4个方法 继承Thread类创建线程 1234567public class MyThread extends Thread&#123;//继承Thread类 public void run()&#123; //重写run方法 &#125;&#125;new MyThread().start();//创建并启动线程 实现Runnable接口创建线程 12345678910111213141516public class MyThread2 implements Runnable &#123;//实现Runnable接口 public void run()&#123; //重写run方法 &#125;&#125;public class Main &#123; public static void main(String[] args)&#123; //创建并启动线程 MyThread2 myThread=new MyThread2(); Thread thread=new Thread(myThread); thread().start(); //或者 new Thread(new MyThread2()).start(); &#125;&#125; 使用Callable和Future创建线程 123456789101112131415public static void main(String[] args) &#123; // 先使用Lambda表达式创建Callable&lt;Integer&gt;对象 // 使用FutureTask来包装Callable对象 FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;((Callable&lt;Integer&gt;)() -&gt; 5); new Thread(task).start(); try &#123; System.out.println(&quot;子线程的返回值：&quot; + task.get()); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; 使用线程池例如用Executor框架","categories":[{"name":"java","slug":"java","permalink":"http://duanyushuai.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://duanyushuai.github.io/tags/java/"}]},{"title":"CompletableFuture","slug":"CompletableFuture","date":"2021-04-05T03:00:23.000Z","updated":"2022-06-13T03:02:59.980Z","comments":true,"path":"2021/04/05/CompletableFuture/","link":"","permalink":"http://duanyushuai.github.io/2021/04/05/CompletableFuture/","excerpt":"","text":"CompletableFuture实例化12345public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier);public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor);public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable);public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor); supply:有返回结果 run：无返回结果 获取结果1234public T get()public T get(long timeout, TimeUnit unit)public T getNow(T valueIfAbsent)public T join() 计算完成后续操作1——complete1234public CompletableFuture&lt;T&gt; whenComplete(BiConsumer&lt;? super T,? super Throwable&gt; action)public CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action)public CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action, Executor executor)public CompletableFuture&lt;T&gt; exceptionally(Function&lt;Throwable,? extends T&gt; fn) 方法1和2的区别在于是否使用异步处理，2和3的区别在于是否使用自定义的线程池，前三个方法都会提供一个返回结果和可抛出异常，我们可以使用lambda表达式的来接收这两个参数，然后自己处理。 方法4，接收一个可抛出的异常，且必须return一个返回值，类型与钻石表达式种的类型一样，详见下文的exceptionally() 例子1234567CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123; return 10086; &#125;); future.whenComplete((result, error) -&gt; &#123; System.out.println(&quot;拨打&quot;+result); error.printStackTrace(); &#125;); whenCompleteAsync 与 whenComplete 区别 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) throws Exception &#123; CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;Integer&gt;(); new Thread(() -&gt; &#123; // 子线程A启动 logger.info(&quot;子线程A启动&quot;); try &#123; logger.info(&quot;子线程A沉睡5s&quot;); Thread.sleep(5000l); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; logger.info(&quot;子线程A令future完成&quot;); f.complete(100); // 当子线程A执行到f.complete的时候，会去看是否有注册好的f的then或者when（非async的），如果有的话，会顺次去执行。 logger.info(&quot;子线程A结束&quot;); &#125;).start();; // 当前线程（主线程）执行到这里的时候，如果子线程还没有执行到f.complete(100)， // 那么当前线程会把whenComplete事件注册起来，并且说好哪个线程执行了f.complete(100)， // 哪个线程就负责执行whenComplete的内容。 // 如果当前线程（主线程）执行到这里的时候，f.complete(100)已经被其他线程执行完毕了。 // 那么只有当前线程自己来执行whenComplete里面的内容了。 f.whenCompleteAsync((i, ex) -&gt; &#123; // 这个场景下，whenComplete的回调的执行线程会是子线程A logger.info(&quot;do something after complete begin&quot;); try &#123; logger.info(&quot;沉睡10s&quot;); Thread.sleep(10000l); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; logger.info(&quot;do something after complete end&quot;); &#125;); logger.info(&quot;main over&quot;); System.in.read();&#125; 计算完成后续操作2——handle123public &lt;U&gt; CompletableFuture&lt;U&gt; handle(BiFunction&lt;? super T,Throwable,? extends U&gt; fn)public &lt;U&gt; CompletableFuture&lt;U&gt; handleAsync(BiFunction&lt;? super T,Throwable,? extends U&gt; fn)public &lt;U&gt; CompletableFuture&lt;U&gt; handleAsync(BiFunction&lt;? super T,Throwable,? extends U&gt; fn, Executor executor) 方法返回类型可以自定义","categories":[{"name":"java","slug":"java","permalink":"http://duanyushuai.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://duanyushuai.github.io/tags/java/"},{"name":"CompletableFuture","slug":"CompletableFuture","permalink":"http://duanyushuai.github.io/tags/CompletableFuture/"}]},{"title":"Jvisualvm","slug":"Jvisualvm","date":"2021-03-10T02:00:00.000Z","updated":"2022-07-24T13:18:06.389Z","comments":true,"path":"2021/03/10/Jvisualvm/","link":"","permalink":"http://duanyushuai.github.io/2021/03/10/Jvisualvm/","excerpt":"","text":"Jvisualvm下载https://visualvm.github.io/download.html 打开扩大字体打开bin 1visualvm.exe --fontsize 20 下载 visual GC 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。","categories":[{"name":"java","slug":"java","permalink":"http://duanyushuai.github.io/categories/java/"},{"name":"Jvisualvm","slug":"java/Jvisualvm","permalink":"http://duanyushuai.github.io/categories/java/Jvisualvm/"}],"tags":[{"name":"java","slug":"java","permalink":"http://duanyushuai.github.io/tags/java/"}]},{"title":"maven","slug":"maven_20220711_172008","date":"2021-03-09T02:00:00.000Z","updated":"2022-07-24T13:18:04.266Z","comments":true,"path":"2021/03/09/maven_20220711_172008/","link":"","permalink":"http://duanyushuai.github.io/2021/03/09/maven_20220711_172008/","excerpt":"","text":"mavenmaven 私服配置setting配置 项目 pom.xml配置maven私服访问地址因为maven默认会有一个下载地址，我们要重写下载地址，改写成自己的私服地址 如果需要打包到私服，需要配置打包私服相关参数 reository和mirror加载顺序1、在mirrorOf与repositoryId相同的时候优先是使用mirror的地址 2、mirrorOf等于*的时候覆盖所有repository配置 3、存在多个mirror配置的时候mirrorOf等于*放到最后 4、只配置mirrorOf为central的时候可以不用配置repository","categories":[{"name":"maven","slug":"maven","permalink":"http://duanyushuai.github.io/categories/maven/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://duanyushuai.github.io/tags/maven/"}]},{"title":"mysql中join的使用","slug":"mysql中join的使用","date":"2021-01-03T02:00:00.000Z","updated":"2022-06-26T10:39:21.188Z","comments":true,"path":"2021/01/03/mysql中join的使用/","link":"","permalink":"http://duanyushuai.github.io/2021/01/03/mysql%E4%B8%ADjoin%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"mysql 中join的使用","categories":[],"tags":[]},{"title":"基于胶囊网络的肽段预测","slug":"基于胶囊网络的肽段预测","date":"2020-09-10T02:00:21.000Z","updated":"2022-06-13T15:28:01.541Z","comments":true,"path":"2020/09/10/基于胶囊网络的肽段预测/","link":"","permalink":"http://duanyushuai.github.io/2020/09/10/%E5%9F%BA%E4%BA%8E%E8%83%B6%E5%9B%8A%E7%BD%91%E7%BB%9C%E7%9A%84%E8%82%BD%E6%AE%B5%E9%A2%84%E6%B5%8B/","excerpt":"","text":"Prediction of Peptide Detectability Based on CapsNet and Convolutional Block Attention Modulehttps://www.mdpi.com/1422-0067/22/21/12080","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://duanyushuai.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://duanyushuai.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"python","slug":"python","permalink":"http://duanyushuai.github.io/tags/python/"},{"name":"深度学习","slug":"深度学习","permalink":"http://duanyushuai.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]}],"categories":[{"name":"springboot","slug":"springboot","permalink":"http://duanyushuai.github.io/categories/springboot/"},{"name":"java web","slug":"java-web","permalink":"http://duanyushuai.github.io/categories/java-web/"},{"name":"Guava","slug":"Guava","permalink":"http://duanyushuai.github.io/categories/Guava/"},{"name":"redis","slug":"Guava/redis","permalink":"http://duanyushuai.github.io/categories/Guava/redis/"},{"name":"算法","slug":"算法","permalink":"http://duanyushuai.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"docker","slug":"docker","permalink":"http://duanyushuai.github.io/categories/docker/"},{"name":"谷粒商城","slug":"docker/谷粒商城","permalink":"http://duanyushuai.github.io/categories/docker/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/"},{"name":"工具","slug":"工具","permalink":"http://duanyushuai.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"rabbitMQ","slug":"rabbitMQ","permalink":"http://duanyushuai.github.io/categories/rabbitMQ/"},{"name":"java","slug":"java","permalink":"http://duanyushuai.github.io/categories/java/"},{"name":"Jvisualvm","slug":"java/Jvisualvm","permalink":"http://duanyushuai.github.io/categories/java/Jvisualvm/"},{"name":"maven","slug":"maven","permalink":"http://duanyushuai.github.io/categories/maven/"},{"name":"深度学习","slug":"深度学习","permalink":"http://duanyushuai.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://duanyushuai.github.io/tags/springboot/"},{"name":"链表","slug":"链表","permalink":"http://duanyushuai.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"java web","slug":"java-web","permalink":"http://duanyushuai.github.io/tags/java-web/"},{"name":"Guava","slug":"Guava","permalink":"http://duanyushuai.github.io/tags/Guava/"},{"name":"redis","slug":"redis","permalink":"http://duanyushuai.github.io/tags/redis/"},{"name":"算法","slug":"算法","permalink":"http://duanyushuai.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"docker","slug":"docker","permalink":"http://duanyushuai.github.io/tags/docker/"},{"name":"工具","slug":"工具","permalink":"http://duanyushuai.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"rabbitMQ","slug":"rabbitMQ","permalink":"http://duanyushuai.github.io/tags/rabbitMQ/"},{"name":"java","slug":"java","permalink":"http://duanyushuai.github.io/tags/java/"},{"name":"HashMap","slug":"HashMap","permalink":"http://duanyushuai.github.io/tags/HashMap/"},{"name":"CompletableFuture","slug":"CompletableFuture","permalink":"http://duanyushuai.github.io/tags/CompletableFuture/"},{"name":"maven","slug":"maven","permalink":"http://duanyushuai.github.io/tags/maven/"},{"name":"python","slug":"python","permalink":"http://duanyushuai.github.io/tags/python/"},{"name":"深度学习","slug":"深度学习","permalink":"http://duanyushuai.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]}