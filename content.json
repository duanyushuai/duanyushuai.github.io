{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"书单","date":"2022-06-12T06:25:36.580Z","updated":"2022-06-12T03:50:30.584Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-06-12T06:28:38.098Z","updated":"2022-06-12T03:50:30.584Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2022-06-12T06:28:38.114Z","updated":"2022-06-12T03:50:30.584Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-06-12T06:28:38.126Z","updated":"2022-06-12T03:50:30.584Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-06-12T06:28:38.138Z","updated":"2022-06-12T03:50:30.584Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-06-12T06:28:38.149Z","updated":"2022-06-12T06:24:49.702Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"Duan","date":"2022-06-12T09:02:04.255Z","updated":"2022-06-13T00:32:33.427Z","comments":true,"path":"2022/06/12/Duan/","link":"","permalink":"http://example.com/2022/06/12/Duan/","excerpt":"","text":"Duantest","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-06-12T03:48:42.697Z","updated":"2022-06-12T03:48:42.697Z","comments":true,"path":"2022/06/12/hello-world/","link":"","permalink":"http://example.com/2022/06/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"CompletableFuture","slug":"CompletableFuture","date":"2022-04-24T07:29:34.000Z","updated":"2022-06-13T02:30:47.074Z","comments":true,"path":"2022/04/24/CompletableFuture/","link":"","permalink":"http://example.com/2022/04/24/CompletableFuture/","excerpt":"","text":"CompletableFuture实例化12345public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier);public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor);public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable);public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor); supply:有返回结果 run：无返回结果 获取结果1234public T get()public T get(long timeout, TimeUnit unit)public T getNow(T valueIfAbsent)public T join() 计算完成后续操作1——complete1234public CompletableFuture&lt;T&gt; whenComplete(BiConsumer&lt;? super T,? super Throwable&gt; action)public CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action)public CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action, Executor executor)public CompletableFuture&lt;T&gt; exceptionally(Function&lt;Throwable,? extends T&gt; fn) 方法1和2的区别在于是否使用异步处理，2和3的区别在于是否使用自定义的线程池，前三个方法都会提供一个返回结果和可抛出异常，我们可以使用lambda表达式的来接收这两个参数，然后自己处理。 方法4，接收一个可抛出的异常，且必须return一个返回值，类型与钻石表达式种的类型一样，详见下文的exceptionally() 例子1234567CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123; return 10086; &#125;); future.whenComplete((result, error) -&gt; &#123; System.out.println(&quot;拨打&quot;+result); error.printStackTrace(); &#125;); whenCompleteAsync 与 whenComplete 区别 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) throws Exception &#123; CompletableFuture&lt;Integer&gt; f = new CompletableFuture&lt;Integer&gt;(); new Thread(() -&gt; &#123; // 子线程A启动 logger.info(&quot;子线程A启动&quot;); try &#123; logger.info(&quot;子线程A沉睡5s&quot;); Thread.sleep(5000l); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; logger.info(&quot;子线程A令future完成&quot;); f.complete(100); // 当子线程A执行到f.complete的时候，会去看是否有注册好的f的then或者when（非async的），如果有的话，会顺次去执行。 logger.info(&quot;子线程A结束&quot;); &#125;).start();; // 当前线程（主线程）执行到这里的时候，如果子线程还没有执行到f.complete(100)， // 那么当前线程会把whenComplete事件注册起来，并且说好哪个线程执行了f.complete(100)， // 哪个线程就负责执行whenComplete的内容。 // 如果当前线程（主线程）执行到这里的时候，f.complete(100)已经被其他线程执行完毕了。 // 那么只有当前线程自己来执行whenComplete里面的内容了。 f.whenCompleteAsync((i, ex) -&gt; &#123; // 这个场景下，whenComplete的回调的执行线程会是子线程A logger.info(&quot;do something after complete begin&quot;); try &#123; logger.info(&quot;沉睡10s&quot;); Thread.sleep(10000l); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; logger.info(&quot;do something after complete end&quot;); &#125;); logger.info(&quot;main over&quot;); System.in.read();&#125; 计算完成后续操作2——handle123public &lt;U&gt; CompletableFuture&lt;U&gt; handle(BiFunction&lt;? super T,Throwable,? extends U&gt; fn)public &lt;U&gt; CompletableFuture&lt;U&gt; handleAsync(BiFunction&lt;? super T,Throwable,? extends U&gt; fn)public &lt;U&gt; CompletableFuture&lt;U&gt; handleAsync(BiFunction&lt;? super T,Throwable,? extends U&gt; fn, Executor executor) 方法返回类型可以自定义","categories":[],"tags":[]}],"categories":[],"tags":[]}